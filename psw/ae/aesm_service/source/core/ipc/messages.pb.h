// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace aesm {
namespace message {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Request;
class Request_CheckUpdateStatusRequest;
class Request_GetLaunchTokenRequest;
class Request_GetQuoteExRequest;
class Request_GetQuoteRequest;
class Request_GetQuoteSizeExRequest;
class Request_GetSupportedAttKeyIDNumRequest;
class Request_GetSupportedAttKeyIDsRequest;
class Request_GetWhiteListRequest;
class Request_GetWhiteListSizeRequest;
class Request_InitQuoteExRequest;
class Request_InitQuoteRequest;
class Request_ReportAttestationErrorRequest;
class Request_SGXGetExtendedEpidGroupIdRequest;
class Request_SGXRegisterRequest;
class Request_SGXSwitchExtendedEpidGroupRequest;
class Request_SelectAttKeyIDRequest;
class Response;
class Response_CheckUpdateStatusResponse;
class Response_GetLaunchTokenResponse;
class Response_GetQuoteExResponse;
class Response_GetQuoteResponse;
class Response_GetQuoteSizeExResponse;
class Response_GetSupportedAttKeyIDNumResponse;
class Response_GetSupportedAttKeyIDsResponse;
class Response_GetWhiteListResponse;
class Response_GetWhiteListSizeResponse;
class Response_InitQuoteExResponse;
class Response_InitQuoteResponse;
class Response_ReportAttestationErrorResponse;
class Response_SGXGetExtendedEpidGroupIdResponse;
class Response_SGXRegisterResponse;
class Response_SGXSwitchExtendedEpidGroupResponse;
class Response_SelectAttKeyIDResponse;
class Response_UnsupportedRequestResponse;

// ===================================================================

class Request_InitQuoteRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.InitQuoteRequest) */ {
 public:
  Request_InitQuoteRequest();
  virtual ~Request_InitQuoteRequest();

  Request_InitQuoteRequest(const Request_InitQuoteRequest& from);

  inline Request_InitQuoteRequest& operator=(const Request_InitQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_InitQuoteRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_InitQuoteRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_InitQuoteRequest* other);

  // implements Message ----------------------------------------------

  inline Request_InitQuoteRequest* New() const { return New(NULL); }

  Request_InitQuoteRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_InitQuoteRequest& from);
  void MergeFrom(const Request_InitQuoteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_InitQuoteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.InitQuoteRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_InitQuoteRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetQuoteRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetQuoteRequest) */ {
 public:
  Request_GetQuoteRequest();
  virtual ~Request_GetQuoteRequest();

  Request_GetQuoteRequest(const Request_GetQuoteRequest& from);

  inline Request_GetQuoteRequest& operator=(const Request_GetQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetQuoteRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetQuoteRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetQuoteRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetQuoteRequest* New() const { return New(NULL); }

  Request_GetQuoteRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetQuoteRequest& from);
  void MergeFrom(const Request_GetQuoteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetQuoteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes report = 1;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 1;
  const ::std::string& report() const;
  void set_report(const ::std::string& value);
  void set_report(const char* value);
  void set_report(const void* value, size_t size);
  ::std::string* mutable_report();
  ::std::string* release_report();
  void set_allocated_report(::std::string* report);

  // required uint32 quote_type = 2;
  bool has_quote_type() const;
  void clear_quote_type();
  static const int kQuoteTypeFieldNumber = 2;
  ::google::protobuf::uint32 quote_type() const;
  void set_quote_type(::google::protobuf::uint32 value);

  // required bytes spid = 3;
  bool has_spid() const;
  void clear_spid();
  static const int kSpidFieldNumber = 3;
  const ::std::string& spid() const;
  void set_spid(const ::std::string& value);
  void set_spid(const char* value);
  void set_spid(const void* value, size_t size);
  ::std::string* mutable_spid();
  ::std::string* release_spid();
  void set_allocated_spid(::std::string* spid);

  // optional bytes nonce = 4;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // optional bytes sig_rl = 5;
  bool has_sig_rl() const;
  void clear_sig_rl();
  static const int kSigRlFieldNumber = 5;
  const ::std::string& sig_rl() const;
  void set_sig_rl(const ::std::string& value);
  void set_sig_rl(const char* value);
  void set_sig_rl(const void* value, size_t size);
  ::std::string* mutable_sig_rl();
  ::std::string* release_sig_rl();
  void set_allocated_sig_rl(::std::string* sig_rl);

  // required uint32 buf_size = 6;
  bool has_buf_size() const;
  void clear_buf_size();
  static const int kBufSizeFieldNumber = 6;
  ::google::protobuf::uint32 buf_size() const;
  void set_buf_size(::google::protobuf::uint32 value);

  // optional bool qe_report = 7;
  bool has_qe_report() const;
  void clear_qe_report();
  static const int kQeReportFieldNumber = 7;
  bool qe_report() const;
  void set_qe_report(bool value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetQuoteRequest)
 private:
  inline void set_has_report();
  inline void clear_has_report();
  inline void set_has_quote_type();
  inline void clear_has_quote_type();
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_sig_rl();
  inline void clear_has_sig_rl();
  inline void set_has_buf_size();
  inline void clear_has_buf_size();
  inline void set_has_qe_report();
  inline void clear_has_qe_report();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr report_;
  ::google::protobuf::internal::ArenaStringPtr spid_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::uint32 quote_type_;
  ::google::protobuf::uint32 buf_size_;
  ::google::protobuf::internal::ArenaStringPtr sig_rl_;
  bool qe_report_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetQuoteRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetLaunchTokenRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetLaunchTokenRequest) */ {
 public:
  Request_GetLaunchTokenRequest();
  virtual ~Request_GetLaunchTokenRequest();

  Request_GetLaunchTokenRequest(const Request_GetLaunchTokenRequest& from);

  inline Request_GetLaunchTokenRequest& operator=(const Request_GetLaunchTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetLaunchTokenRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetLaunchTokenRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetLaunchTokenRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetLaunchTokenRequest* New() const { return New(NULL); }

  Request_GetLaunchTokenRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetLaunchTokenRequest& from);
  void MergeFrom(const Request_GetLaunchTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetLaunchTokenRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes mr_enclave = 1;
  bool has_mr_enclave() const;
  void clear_mr_enclave();
  static const int kMrEnclaveFieldNumber = 1;
  const ::std::string& mr_enclave() const;
  void set_mr_enclave(const ::std::string& value);
  void set_mr_enclave(const char* value);
  void set_mr_enclave(const void* value, size_t size);
  ::std::string* mutable_mr_enclave();
  ::std::string* release_mr_enclave();
  void set_allocated_mr_enclave(::std::string* mr_enclave);

  // required bytes mr_signer = 2;
  bool has_mr_signer() const;
  void clear_mr_signer();
  static const int kMrSignerFieldNumber = 2;
  const ::std::string& mr_signer() const;
  void set_mr_signer(const ::std::string& value);
  void set_mr_signer(const char* value);
  void set_mr_signer(const void* value, size_t size);
  ::std::string* mutable_mr_signer();
  ::std::string* release_mr_signer();
  void set_allocated_mr_signer(::std::string* mr_signer);

  // required bytes se_attributes = 3;
  bool has_se_attributes() const;
  void clear_se_attributes();
  static const int kSeAttributesFieldNumber = 3;
  const ::std::string& se_attributes() const;
  void set_se_attributes(const ::std::string& value);
  void set_se_attributes(const char* value);
  void set_se_attributes(const void* value, size_t size);
  ::std::string* mutable_se_attributes();
  ::std::string* release_se_attributes();
  void set_allocated_se_attributes(::std::string* se_attributes);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetLaunchTokenRequest)
 private:
  inline void set_has_mr_enclave();
  inline void clear_has_mr_enclave();
  inline void set_has_mr_signer();
  inline void clear_has_mr_signer();
  inline void set_has_se_attributes();
  inline void clear_has_se_attributes();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mr_enclave_;
  ::google::protobuf::internal::ArenaStringPtr mr_signer_;
  ::google::protobuf::internal::ArenaStringPtr se_attributes_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetLaunchTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_ReportAttestationErrorRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.ReportAttestationErrorRequest) */ {
 public:
  Request_ReportAttestationErrorRequest();
  virtual ~Request_ReportAttestationErrorRequest();

  Request_ReportAttestationErrorRequest(const Request_ReportAttestationErrorRequest& from);

  inline Request_ReportAttestationErrorRequest& operator=(const Request_ReportAttestationErrorRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_ReportAttestationErrorRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_ReportAttestationErrorRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_ReportAttestationErrorRequest* other);

  // implements Message ----------------------------------------------

  inline Request_ReportAttestationErrorRequest* New() const { return New(NULL); }

  Request_ReportAttestationErrorRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_ReportAttestationErrorRequest& from);
  void MergeFrom(const Request_ReportAttestationErrorRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_ReportAttestationErrorRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes platform_info = 1;
  bool has_platform_info() const;
  void clear_platform_info();
  static const int kPlatformInfoFieldNumber = 1;
  const ::std::string& platform_info() const;
  void set_platform_info(const ::std::string& value);
  void set_platform_info(const char* value);
  void set_platform_info(const void* value, size_t size);
  ::std::string* mutable_platform_info();
  ::std::string* release_platform_info();
  void set_allocated_platform_info(::std::string* platform_info);

  // required uint32 attestation_error_code = 2;
  bool has_attestation_error_code() const;
  void clear_attestation_error_code();
  static const int kAttestationErrorCodeFieldNumber = 2;
  ::google::protobuf::uint32 attestation_error_code() const;
  void set_attestation_error_code(::google::protobuf::uint32 value);

  // required uint32 update_info_size = 3;
  bool has_update_info_size() const;
  void clear_update_info_size();
  static const int kUpdateInfoSizeFieldNumber = 3;
  ::google::protobuf::uint32 update_info_size() const;
  void set_update_info_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.ReportAttestationErrorRequest)
 private:
  inline void set_has_platform_info();
  inline void clear_has_platform_info();
  inline void set_has_attestation_error_code();
  inline void clear_has_attestation_error_code();
  inline void set_has_update_info_size();
  inline void clear_has_update_info_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr platform_info_;
  ::google::protobuf::uint32 attestation_error_code_;
  ::google::protobuf::uint32 update_info_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ReportAttestationErrorRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_CheckUpdateStatusRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.CheckUpdateStatusRequest) */ {
 public:
  Request_CheckUpdateStatusRequest();
  virtual ~Request_CheckUpdateStatusRequest();

  Request_CheckUpdateStatusRequest(const Request_CheckUpdateStatusRequest& from);

  inline Request_CheckUpdateStatusRequest& operator=(const Request_CheckUpdateStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_CheckUpdateStatusRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_CheckUpdateStatusRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_CheckUpdateStatusRequest* other);

  // implements Message ----------------------------------------------

  inline Request_CheckUpdateStatusRequest* New() const { return New(NULL); }

  Request_CheckUpdateStatusRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_CheckUpdateStatusRequest& from);
  void MergeFrom(const Request_CheckUpdateStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_CheckUpdateStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes platform_info = 1;
  bool has_platform_info() const;
  void clear_platform_info();
  static const int kPlatformInfoFieldNumber = 1;
  const ::std::string& platform_info() const;
  void set_platform_info(const ::std::string& value);
  void set_platform_info(const char* value);
  void set_platform_info(const void* value, size_t size);
  ::std::string* mutable_platform_info();
  ::std::string* release_platform_info();
  void set_allocated_platform_info(::std::string* platform_info);

  // required uint32 update_info_size = 2;
  bool has_update_info_size() const;
  void clear_update_info_size();
  static const int kUpdateInfoSizeFieldNumber = 2;
  ::google::protobuf::uint32 update_info_size() const;
  void set_update_info_size(::google::protobuf::uint32 value);

  // required uint32 config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  ::google::protobuf::uint32 config() const;
  void set_config(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.CheckUpdateStatusRequest)
 private:
  inline void set_has_platform_info();
  inline void clear_has_platform_info();
  inline void set_has_update_info_size();
  inline void clear_has_update_info_size();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr platform_info_;
  ::google::protobuf::uint32 update_info_size_;
  ::google::protobuf::uint32 config_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_CheckUpdateStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetWhiteListSizeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetWhiteListSizeRequest) */ {
 public:
  Request_GetWhiteListSizeRequest();
  virtual ~Request_GetWhiteListSizeRequest();

  Request_GetWhiteListSizeRequest(const Request_GetWhiteListSizeRequest& from);

  inline Request_GetWhiteListSizeRequest& operator=(const Request_GetWhiteListSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetWhiteListSizeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetWhiteListSizeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetWhiteListSizeRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetWhiteListSizeRequest* New() const { return New(NULL); }

  Request_GetWhiteListSizeRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetWhiteListSizeRequest& from);
  void MergeFrom(const Request_GetWhiteListSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetWhiteListSizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetWhiteListSizeRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetWhiteListSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetWhiteListRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetWhiteListRequest) */ {
 public:
  Request_GetWhiteListRequest();
  virtual ~Request_GetWhiteListRequest();

  Request_GetWhiteListRequest(const Request_GetWhiteListRequest& from);

  inline Request_GetWhiteListRequest& operator=(const Request_GetWhiteListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetWhiteListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetWhiteListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetWhiteListRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetWhiteListRequest* New() const { return New(NULL); }

  Request_GetWhiteListRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetWhiteListRequest& from);
  void MergeFrom(const Request_GetWhiteListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetWhiteListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 white_list_size = 1;
  bool has_white_list_size() const;
  void clear_white_list_size();
  static const int kWhiteListSizeFieldNumber = 1;
  ::google::protobuf::uint32 white_list_size() const;
  void set_white_list_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetWhiteListRequest)
 private:
  inline void set_has_white_list_size();
  inline void clear_has_white_list_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 white_list_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetWhiteListRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SGXGetExtendedEpidGroupIdRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.SGXGetExtendedEpidGroupIdRequest) */ {
 public:
  Request_SGXGetExtendedEpidGroupIdRequest();
  virtual ~Request_SGXGetExtendedEpidGroupIdRequest();

  Request_SGXGetExtendedEpidGroupIdRequest(const Request_SGXGetExtendedEpidGroupIdRequest& from);

  inline Request_SGXGetExtendedEpidGroupIdRequest& operator=(const Request_SGXGetExtendedEpidGroupIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_SGXGetExtendedEpidGroupIdRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_SGXGetExtendedEpidGroupIdRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_SGXGetExtendedEpidGroupIdRequest* other);

  // implements Message ----------------------------------------------

  inline Request_SGXGetExtendedEpidGroupIdRequest* New() const { return New(NULL); }

  Request_SGXGetExtendedEpidGroupIdRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_SGXGetExtendedEpidGroupIdRequest& from);
  void MergeFrom(const Request_SGXGetExtendedEpidGroupIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_SGXGetExtendedEpidGroupIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SGXGetExtendedEpidGroupIdRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SGXGetExtendedEpidGroupIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SGXSwitchExtendedEpidGroupRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest) */ {
 public:
  Request_SGXSwitchExtendedEpidGroupRequest();
  virtual ~Request_SGXSwitchExtendedEpidGroupRequest();

  Request_SGXSwitchExtendedEpidGroupRequest(const Request_SGXSwitchExtendedEpidGroupRequest& from);

  inline Request_SGXSwitchExtendedEpidGroupRequest& operator=(const Request_SGXSwitchExtendedEpidGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_SGXSwitchExtendedEpidGroupRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_SGXSwitchExtendedEpidGroupRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_SGXSwitchExtendedEpidGroupRequest* other);

  // implements Message ----------------------------------------------

  inline Request_SGXSwitchExtendedEpidGroupRequest* New() const { return New(NULL); }

  Request_SGXSwitchExtendedEpidGroupRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_SGXSwitchExtendedEpidGroupRequest& from);
  void MergeFrom(const Request_SGXSwitchExtendedEpidGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_SGXSwitchExtendedEpidGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 x_group_id = 1;
  bool has_x_group_id() const;
  void clear_x_group_id();
  static const int kXGroupIdFieldNumber = 1;
  ::google::protobuf::uint32 x_group_id() const;
  void set_x_group_id(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest)
 private:
  inline void set_has_x_group_id();
  inline void clear_has_x_group_id();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_group_id_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SGXSwitchExtendedEpidGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SGXRegisterRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.SGXRegisterRequest) */ {
 public:
  Request_SGXRegisterRequest();
  virtual ~Request_SGXRegisterRequest();

  Request_SGXRegisterRequest(const Request_SGXRegisterRequest& from);

  inline Request_SGXRegisterRequest& operator=(const Request_SGXRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_SGXRegisterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_SGXRegisterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_SGXRegisterRequest* other);

  // implements Message ----------------------------------------------

  inline Request_SGXRegisterRequest* New() const { return New(NULL); }

  Request_SGXRegisterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_SGXRegisterRequest& from);
  void MergeFrom(const Request_SGXRegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_SGXRegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes buf = 1;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 1;
  const ::std::string& buf() const;
  void set_buf(const ::std::string& value);
  void set_buf(const char* value);
  void set_buf(const void* value, size_t size);
  ::std::string* mutable_buf();
  ::std::string* release_buf();
  void set_allocated_buf(::std::string* buf);

  // required uint32 data_type = 2;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::google::protobuf::uint32 data_type() const;
  void set_data_type(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SGXRegisterRequest)
 private:
  inline void set_has_buf();
  inline void clear_has_buf();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buf_;
  ::google::protobuf::uint32 data_type_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SGXRegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_InitQuoteExRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.InitQuoteExRequest) */ {
 public:
  Request_InitQuoteExRequest();
  virtual ~Request_InitQuoteExRequest();

  Request_InitQuoteExRequest(const Request_InitQuoteExRequest& from);

  inline Request_InitQuoteExRequest& operator=(const Request_InitQuoteExRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_InitQuoteExRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_InitQuoteExRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_InitQuoteExRequest* other);

  // implements Message ----------------------------------------------

  inline Request_InitQuoteExRequest* New() const { return New(NULL); }

  Request_InitQuoteExRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_InitQuoteExRequest& from);
  void MergeFrom(const Request_InitQuoteExRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_InitQuoteExRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes att_key_id = 1;
  bool has_att_key_id() const;
  void clear_att_key_id();
  static const int kAttKeyIdFieldNumber = 1;
  const ::std::string& att_key_id() const;
  void set_att_key_id(const ::std::string& value);
  void set_att_key_id(const char* value);
  void set_att_key_id(const void* value, size_t size);
  ::std::string* mutable_att_key_id();
  ::std::string* release_att_key_id();
  void set_allocated_att_key_id(::std::string* att_key_id);

  // required bool b_pub_key_id = 3;
  bool has_b_pub_key_id() const;
  void clear_b_pub_key_id();
  static const int kBPubKeyIdFieldNumber = 3;
  bool b_pub_key_id() const;
  void set_b_pub_key_id(bool value);

  // optional uint64 buf_size = 4;
  bool has_buf_size() const;
  void clear_buf_size();
  static const int kBufSizeFieldNumber = 4;
  ::google::protobuf::uint64 buf_size() const;
  void set_buf_size(::google::protobuf::uint64 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.InitQuoteExRequest)
 private:
  inline void set_has_att_key_id();
  inline void clear_has_att_key_id();
  inline void set_has_b_pub_key_id();
  inline void clear_has_b_pub_key_id();
  inline void set_has_buf_size();
  inline void clear_has_buf_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr att_key_id_;
  ::google::protobuf::uint64 buf_size_;
  bool b_pub_key_id_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_InitQuoteExRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_SelectAttKeyIDRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.SelectAttKeyIDRequest) */ {
 public:
  Request_SelectAttKeyIDRequest();
  virtual ~Request_SelectAttKeyIDRequest();

  Request_SelectAttKeyIDRequest(const Request_SelectAttKeyIDRequest& from);

  inline Request_SelectAttKeyIDRequest& operator=(const Request_SelectAttKeyIDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_SelectAttKeyIDRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_SelectAttKeyIDRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_SelectAttKeyIDRequest* other);

  // implements Message ----------------------------------------------

  inline Request_SelectAttKeyIDRequest* New() const { return New(NULL); }

  Request_SelectAttKeyIDRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_SelectAttKeyIDRequest& from);
  void MergeFrom(const Request_SelectAttKeyIDRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_SelectAttKeyIDRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes att_key_id_list = 1;
  bool has_att_key_id_list() const;
  void clear_att_key_id_list();
  static const int kAttKeyIdListFieldNumber = 1;
  const ::std::string& att_key_id_list() const;
  void set_att_key_id_list(const ::std::string& value);
  void set_att_key_id_list(const char* value);
  void set_att_key_id_list(const void* value, size_t size);
  ::std::string* mutable_att_key_id_list();
  ::std::string* release_att_key_id_list();
  void set_allocated_att_key_id_list(::std::string* att_key_id_list);

  // optional uint32 timeout = 2;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.SelectAttKeyIDRequest)
 private:
  inline void set_has_att_key_id_list();
  inline void clear_has_att_key_id_list();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr att_key_id_list_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_SelectAttKeyIDRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetQuoteSizeExRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetQuoteSizeExRequest) */ {
 public:
  Request_GetQuoteSizeExRequest();
  virtual ~Request_GetQuoteSizeExRequest();

  Request_GetQuoteSizeExRequest(const Request_GetQuoteSizeExRequest& from);

  inline Request_GetQuoteSizeExRequest& operator=(const Request_GetQuoteSizeExRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetQuoteSizeExRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetQuoteSizeExRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetQuoteSizeExRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetQuoteSizeExRequest* New() const { return New(NULL); }

  Request_GetQuoteSizeExRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetQuoteSizeExRequest& from);
  void MergeFrom(const Request_GetQuoteSizeExRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetQuoteSizeExRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes att_key_id = 1;
  bool has_att_key_id() const;
  void clear_att_key_id();
  static const int kAttKeyIdFieldNumber = 1;
  const ::std::string& att_key_id() const;
  void set_att_key_id(const ::std::string& value);
  void set_att_key_id(const char* value);
  void set_att_key_id(const void* value, size_t size);
  ::std::string* mutable_att_key_id();
  ::std::string* release_att_key_id();
  void set_allocated_att_key_id(::std::string* att_key_id);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetQuoteSizeExRequest)
 private:
  inline void set_has_att_key_id();
  inline void clear_has_att_key_id();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr att_key_id_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetQuoteSizeExRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetQuoteExRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetQuoteExRequest) */ {
 public:
  Request_GetQuoteExRequest();
  virtual ~Request_GetQuoteExRequest();

  Request_GetQuoteExRequest(const Request_GetQuoteExRequest& from);

  inline Request_GetQuoteExRequest& operator=(const Request_GetQuoteExRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetQuoteExRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetQuoteExRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetQuoteExRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetQuoteExRequest* New() const { return New(NULL); }

  Request_GetQuoteExRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetQuoteExRequest& from);
  void MergeFrom(const Request_GetQuoteExRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetQuoteExRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes report = 1;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 1;
  const ::std::string& report() const;
  void set_report(const ::std::string& value);
  void set_report(const char* value);
  void set_report(const void* value, size_t size);
  ::std::string* mutable_report();
  ::std::string* release_report();
  void set_allocated_report(::std::string* report);

  // optional bytes att_key_id = 2;
  bool has_att_key_id() const;
  void clear_att_key_id();
  static const int kAttKeyIdFieldNumber = 2;
  const ::std::string& att_key_id() const;
  void set_att_key_id(const ::std::string& value);
  void set_att_key_id(const char* value);
  void set_att_key_id(const void* value, size_t size);
  ::std::string* mutable_att_key_id();
  ::std::string* release_att_key_id();
  void set_allocated_att_key_id(::std::string* att_key_id);

  // optional bytes qe_report_info = 3;
  bool has_qe_report_info() const;
  void clear_qe_report_info();
  static const int kQeReportInfoFieldNumber = 3;
  const ::std::string& qe_report_info() const;
  void set_qe_report_info(const ::std::string& value);
  void set_qe_report_info(const char* value);
  void set_qe_report_info(const void* value, size_t size);
  ::std::string* mutable_qe_report_info();
  ::std::string* release_qe_report_info();
  void set_allocated_qe_report_info(::std::string* qe_report_info);

  // required uint32 buf_size = 4;
  bool has_buf_size() const;
  void clear_buf_size();
  static const int kBufSizeFieldNumber = 4;
  ::google::protobuf::uint32 buf_size() const;
  void set_buf_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetQuoteExRequest)
 private:
  inline void set_has_report();
  inline void clear_has_report();
  inline void set_has_att_key_id();
  inline void clear_has_att_key_id();
  inline void set_has_qe_report_info();
  inline void clear_has_qe_report_info();
  inline void set_has_buf_size();
  inline void clear_has_buf_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr report_;
  ::google::protobuf::internal::ArenaStringPtr att_key_id_;
  ::google::protobuf::internal::ArenaStringPtr qe_report_info_;
  ::google::protobuf::uint32 buf_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetQuoteExRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetSupportedAttKeyIDNumRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetSupportedAttKeyIDNumRequest) */ {
 public:
  Request_GetSupportedAttKeyIDNumRequest();
  virtual ~Request_GetSupportedAttKeyIDNumRequest();

  Request_GetSupportedAttKeyIDNumRequest(const Request_GetSupportedAttKeyIDNumRequest& from);

  inline Request_GetSupportedAttKeyIDNumRequest& operator=(const Request_GetSupportedAttKeyIDNumRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetSupportedAttKeyIDNumRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetSupportedAttKeyIDNumRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetSupportedAttKeyIDNumRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetSupportedAttKeyIDNumRequest* New() const { return New(NULL); }

  Request_GetSupportedAttKeyIDNumRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetSupportedAttKeyIDNumRequest& from);
  void MergeFrom(const Request_GetSupportedAttKeyIDNumRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetSupportedAttKeyIDNumRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetSupportedAttKeyIDNumRequest)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetSupportedAttKeyIDNumRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetSupportedAttKeyIDsRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request.GetSupportedAttKeyIDsRequest) */ {
 public:
  Request_GetSupportedAttKeyIDsRequest();
  virtual ~Request_GetSupportedAttKeyIDsRequest();

  Request_GetSupportedAttKeyIDsRequest(const Request_GetSupportedAttKeyIDsRequest& from);

  inline Request_GetSupportedAttKeyIDsRequest& operator=(const Request_GetSupportedAttKeyIDsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request_GetSupportedAttKeyIDsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request_GetSupportedAttKeyIDsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request_GetSupportedAttKeyIDsRequest* other);

  // implements Message ----------------------------------------------

  inline Request_GetSupportedAttKeyIDsRequest* New() const { return New(NULL); }

  Request_GetSupportedAttKeyIDsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request_GetSupportedAttKeyIDsRequest& from);
  void MergeFrom(const Request_GetSupportedAttKeyIDsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_GetSupportedAttKeyIDsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 buf_size = 1;
  bool has_buf_size() const;
  void clear_buf_size();
  static const int kBufSizeFieldNumber = 1;
  ::google::protobuf::uint32 buf_size() const;
  void set_buf_size(::google::protobuf::uint32 value);

  // optional uint32 timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Request.GetSupportedAttKeyIDsRequest)
 private:
  inline void set_has_buf_size();
  inline void clear_has_buf_size();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 buf_size_;
  ::google::protobuf::uint32 timeout_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_GetSupportedAttKeyIDsRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Request_InitQuoteRequest InitQuoteRequest;
  typedef Request_GetQuoteRequest GetQuoteRequest;
  typedef Request_GetLaunchTokenRequest GetLaunchTokenRequest;
  typedef Request_ReportAttestationErrorRequest ReportAttestationErrorRequest;
  typedef Request_CheckUpdateStatusRequest CheckUpdateStatusRequest;
  typedef Request_GetWhiteListSizeRequest GetWhiteListSizeRequest;
  typedef Request_GetWhiteListRequest GetWhiteListRequest;
  typedef Request_SGXGetExtendedEpidGroupIdRequest SGXGetExtendedEpidGroupIdRequest;
  typedef Request_SGXSwitchExtendedEpidGroupRequest SGXSwitchExtendedEpidGroupRequest;
  typedef Request_SGXRegisterRequest SGXRegisterRequest;
  typedef Request_InitQuoteExRequest InitQuoteExRequest;
  typedef Request_SelectAttKeyIDRequest SelectAttKeyIDRequest;
  typedef Request_GetQuoteSizeExRequest GetQuoteSizeExRequest;
  typedef Request_GetQuoteExRequest GetQuoteExRequest;
  typedef Request_GetSupportedAttKeyIDNumRequest GetSupportedAttKeyIDNumRequest;
  typedef Request_GetSupportedAttKeyIDsRequest GetSupportedAttKeyIDsRequest;

  // accessors -------------------------------------------------------

  // optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;
  bool has_initquotereq() const;
  void clear_initquotereq();
  static const int kInitQuoteReqFieldNumber = 1;
  const ::aesm::message::Request_InitQuoteRequest& initquotereq() const;
  ::aesm::message::Request_InitQuoteRequest* mutable_initquotereq();
  ::aesm::message::Request_InitQuoteRequest* release_initquotereq();
  void set_allocated_initquotereq(::aesm::message::Request_InitQuoteRequest* initquotereq);

  // optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;
  bool has_getquotereq() const;
  void clear_getquotereq();
  static const int kGetQuoteReqFieldNumber = 2;
  const ::aesm::message::Request_GetQuoteRequest& getquotereq() const;
  ::aesm::message::Request_GetQuoteRequest* mutable_getquotereq();
  ::aesm::message::Request_GetQuoteRequest* release_getquotereq();
  void set_allocated_getquotereq(::aesm::message::Request_GetQuoteRequest* getquotereq);

  // optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;
  bool has_getlictokenreq() const;
  void clear_getlictokenreq();
  static const int kGetLicTokenReqFieldNumber = 3;
  const ::aesm::message::Request_GetLaunchTokenRequest& getlictokenreq() const;
  ::aesm::message::Request_GetLaunchTokenRequest* mutable_getlictokenreq();
  ::aesm::message::Request_GetLaunchTokenRequest* release_getlictokenreq();
  void set_allocated_getlictokenreq(::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq);

  // optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;
  bool has_reporterrreq() const;
  void clear_reporterrreq();
  static const int kReportErrReqFieldNumber = 4;
  const ::aesm::message::Request_ReportAttestationErrorRequest& reporterrreq() const;
  ::aesm::message::Request_ReportAttestationErrorRequest* mutable_reporterrreq();
  ::aesm::message::Request_ReportAttestationErrorRequest* release_reporterrreq();
  void set_allocated_reporterrreq(::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq);

  // optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;
  bool has_getwhitelistsizereq() const;
  void clear_getwhitelistsizereq();
  static const int kGetWhiteListSizeReqFieldNumber = 10;
  const ::aesm::message::Request_GetWhiteListSizeRequest& getwhitelistsizereq() const;
  ::aesm::message::Request_GetWhiteListSizeRequest* mutable_getwhitelistsizereq();
  ::aesm::message::Request_GetWhiteListSizeRequest* release_getwhitelistsizereq();
  void set_allocated_getwhitelistsizereq(::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq);

  // optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;
  bool has_getwhitelistreq() const;
  void clear_getwhitelistreq();
  static const int kGetWhiteListReqFieldNumber = 11;
  const ::aesm::message::Request_GetWhiteListRequest& getwhitelistreq() const;
  ::aesm::message::Request_GetWhiteListRequest* mutable_getwhitelistreq();
  ::aesm::message::Request_GetWhiteListRequest* release_getwhitelistreq();
  void set_allocated_getwhitelistreq(::aesm::message::Request_GetWhiteListRequest* getwhitelistreq);

  // optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;
  bool has_sgxgetextendedepidgroupidreq() const;
  void clear_sgxgetextendedepidgroupidreq();
  static const int kSgxGetExtendedEpidGroupIdReqFieldNumber = 12;
  const ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest& sgxgetextendedepidgroupidreq() const;
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* mutable_sgxgetextendedepidgroupidreq();
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* release_sgxgetextendedepidgroupidreq();
  void set_allocated_sgxgetextendedepidgroupidreq(::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq);

  // optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;
  bool has_sgxswitchextendedepidgroupreq() const;
  void clear_sgxswitchextendedepidgroupreq();
  static const int kSgxSwitchExtendedEpidGroupReqFieldNumber = 13;
  const ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest& sgxswitchextendedepidgroupreq() const;
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* mutable_sgxswitchextendedepidgroupreq();
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* release_sgxswitchextendedepidgroupreq();
  void set_allocated_sgxswitchextendedepidgroupreq(::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq);

  // optional .aesm.message.Request.SGXRegisterRequest sgxRegisterReq = 14;
  bool has_sgxregisterreq() const;
  void clear_sgxregisterreq();
  static const int kSgxRegisterReqFieldNumber = 14;
  const ::aesm::message::Request_SGXRegisterRequest& sgxregisterreq() const;
  ::aesm::message::Request_SGXRegisterRequest* mutable_sgxregisterreq();
  ::aesm::message::Request_SGXRegisterRequest* release_sgxregisterreq();
  void set_allocated_sgxregisterreq(::aesm::message::Request_SGXRegisterRequest* sgxregisterreq);

  // optional .aesm.message.Request.InitQuoteExRequest initQuoteExReq = 15;
  bool has_initquoteexreq() const;
  void clear_initquoteexreq();
  static const int kInitQuoteExReqFieldNumber = 15;
  const ::aesm::message::Request_InitQuoteExRequest& initquoteexreq() const;
  ::aesm::message::Request_InitQuoteExRequest* mutable_initquoteexreq();
  ::aesm::message::Request_InitQuoteExRequest* release_initquoteexreq();
  void set_allocated_initquoteexreq(::aesm::message::Request_InitQuoteExRequest* initquoteexreq);

  // optional .aesm.message.Request.GetQuoteSizeExRequest getQuoteSizeExReq = 16;
  bool has_getquotesizeexreq() const;
  void clear_getquotesizeexreq();
  static const int kGetQuoteSizeExReqFieldNumber = 16;
  const ::aesm::message::Request_GetQuoteSizeExRequest& getquotesizeexreq() const;
  ::aesm::message::Request_GetQuoteSizeExRequest* mutable_getquotesizeexreq();
  ::aesm::message::Request_GetQuoteSizeExRequest* release_getquotesizeexreq();
  void set_allocated_getquotesizeexreq(::aesm::message::Request_GetQuoteSizeExRequest* getquotesizeexreq);

  // optional .aesm.message.Request.GetQuoteExRequest getQuoteExReq = 17;
  bool has_getquoteexreq() const;
  void clear_getquoteexreq();
  static const int kGetQuoteExReqFieldNumber = 17;
  const ::aesm::message::Request_GetQuoteExRequest& getquoteexreq() const;
  ::aesm::message::Request_GetQuoteExRequest* mutable_getquoteexreq();
  ::aesm::message::Request_GetQuoteExRequest* release_getquoteexreq();
  void set_allocated_getquoteexreq(::aesm::message::Request_GetQuoteExRequest* getquoteexreq);

  // optional .aesm.message.Request.CheckUpdateStatusRequest checkUpdateStatusReq = 18;
  bool has_checkupdatestatusreq() const;
  void clear_checkupdatestatusreq();
  static const int kCheckUpdateStatusReqFieldNumber = 18;
  const ::aesm::message::Request_CheckUpdateStatusRequest& checkupdatestatusreq() const;
  ::aesm::message::Request_CheckUpdateStatusRequest* mutable_checkupdatestatusreq();
  ::aesm::message::Request_CheckUpdateStatusRequest* release_checkupdatestatusreq();
  void set_allocated_checkupdatestatusreq(::aesm::message::Request_CheckUpdateStatusRequest* checkupdatestatusreq);

  // optional .aesm.message.Request.SelectAttKeyIDRequest selectAttKeyIDReq = 19;
  bool has_selectattkeyidreq() const;
  void clear_selectattkeyidreq();
  static const int kSelectAttKeyIDReqFieldNumber = 19;
  const ::aesm::message::Request_SelectAttKeyIDRequest& selectattkeyidreq() const;
  ::aesm::message::Request_SelectAttKeyIDRequest* mutable_selectattkeyidreq();
  ::aesm::message::Request_SelectAttKeyIDRequest* release_selectattkeyidreq();
  void set_allocated_selectattkeyidreq(::aesm::message::Request_SelectAttKeyIDRequest* selectattkeyidreq);

  // optional .aesm.message.Request.GetSupportedAttKeyIDNumRequest getSupportedAttKeyIDNumReq = 21;
  bool has_getsupportedattkeyidnumreq() const;
  void clear_getsupportedattkeyidnumreq();
  static const int kGetSupportedAttKeyIDNumReqFieldNumber = 21;
  const ::aesm::message::Request_GetSupportedAttKeyIDNumRequest& getsupportedattkeyidnumreq() const;
  ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* mutable_getsupportedattkeyidnumreq();
  ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* release_getsupportedattkeyidnumreq();
  void set_allocated_getsupportedattkeyidnumreq(::aesm::message::Request_GetSupportedAttKeyIDNumRequest* getsupportedattkeyidnumreq);

  // optional .aesm.message.Request.GetSupportedAttKeyIDsRequest getSupportedAttKeyIDsReq = 22;
  bool has_getsupportedattkeyidsreq() const;
  void clear_getsupportedattkeyidsreq();
  static const int kGetSupportedAttKeyIDsReqFieldNumber = 22;
  const ::aesm::message::Request_GetSupportedAttKeyIDsRequest& getsupportedattkeyidsreq() const;
  ::aesm::message::Request_GetSupportedAttKeyIDsRequest* mutable_getsupportedattkeyidsreq();
  ::aesm::message::Request_GetSupportedAttKeyIDsRequest* release_getsupportedattkeyidsreq();
  void set_allocated_getsupportedattkeyidsreq(::aesm::message::Request_GetSupportedAttKeyIDsRequest* getsupportedattkeyidsreq);

  // @@protoc_insertion_point(class_scope:aesm.message.Request)
 private:
  inline void set_has_initquotereq();
  inline void clear_has_initquotereq();
  inline void set_has_getquotereq();
  inline void clear_has_getquotereq();
  inline void set_has_getlictokenreq();
  inline void clear_has_getlictokenreq();
  inline void set_has_reporterrreq();
  inline void clear_has_reporterrreq();
  inline void set_has_getwhitelistsizereq();
  inline void clear_has_getwhitelistsizereq();
  inline void set_has_getwhitelistreq();
  inline void clear_has_getwhitelistreq();
  inline void set_has_sgxgetextendedepidgroupidreq();
  inline void clear_has_sgxgetextendedepidgroupidreq();
  inline void set_has_sgxswitchextendedepidgroupreq();
  inline void clear_has_sgxswitchextendedepidgroupreq();
  inline void set_has_sgxregisterreq();
  inline void clear_has_sgxregisterreq();
  inline void set_has_initquoteexreq();
  inline void clear_has_initquoteexreq();
  inline void set_has_getquotesizeexreq();
  inline void clear_has_getquotesizeexreq();
  inline void set_has_getquoteexreq();
  inline void clear_has_getquoteexreq();
  inline void set_has_checkupdatestatusreq();
  inline void clear_has_checkupdatestatusreq();
  inline void set_has_selectattkeyidreq();
  inline void clear_has_selectattkeyidreq();
  inline void set_has_getsupportedattkeyidnumreq();
  inline void clear_has_getsupportedattkeyidnumreq();
  inline void set_has_getsupportedattkeyidsreq();
  inline void clear_has_getsupportedattkeyidsreq();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aesm::message::Request_InitQuoteRequest* initquotereq_;
  ::aesm::message::Request_GetQuoteRequest* getquotereq_;
  ::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq_;
  ::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq_;
  ::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq_;
  ::aesm::message::Request_GetWhiteListRequest* getwhitelistreq_;
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq_;
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq_;
  ::aesm::message::Request_SGXRegisterRequest* sgxregisterreq_;
  ::aesm::message::Request_InitQuoteExRequest* initquoteexreq_;
  ::aesm::message::Request_GetQuoteSizeExRequest* getquotesizeexreq_;
  ::aesm::message::Request_GetQuoteExRequest* getquoteexreq_;
  ::aesm::message::Request_CheckUpdateStatusRequest* checkupdatestatusreq_;
  ::aesm::message::Request_SelectAttKeyIDRequest* selectattkeyidreq_;
  ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* getsupportedattkeyidnumreq_;
  ::aesm::message::Request_GetSupportedAttKeyIDsRequest* getsupportedattkeyidsreq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response_InitQuoteResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.InitQuoteResponse) */ {
 public:
  Response_InitQuoteResponse();
  virtual ~Response_InitQuoteResponse();

  Response_InitQuoteResponse(const Response_InitQuoteResponse& from);

  inline Response_InitQuoteResponse& operator=(const Response_InitQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_InitQuoteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_InitQuoteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_InitQuoteResponse* other);

  // implements Message ----------------------------------------------

  inline Response_InitQuoteResponse* New() const { return New(NULL); }

  Response_InitQuoteResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_InitQuoteResponse& from);
  void MergeFrom(const Response_InitQuoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_InitQuoteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes targetInfo = 2;
  bool has_targetinfo() const;
  void clear_targetinfo();
  static const int kTargetInfoFieldNumber = 2;
  const ::std::string& targetinfo() const;
  void set_targetinfo(const ::std::string& value);
  void set_targetinfo(const char* value);
  void set_targetinfo(const void* value, size_t size);
  ::std::string* mutable_targetinfo();
  ::std::string* release_targetinfo();
  void set_allocated_targetinfo(::std::string* targetinfo);

  // optional bytes gid = 3;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 3;
  const ::std::string& gid() const;
  void set_gid(const ::std::string& value);
  void set_gid(const char* value);
  void set_gid(const void* value, size_t size);
  ::std::string* mutable_gid();
  ::std::string* release_gid();
  void set_allocated_gid(::std::string* gid);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.InitQuoteResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_targetinfo();
  inline void clear_has_targetinfo();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr targetinfo_;
  ::google::protobuf::internal::ArenaStringPtr gid_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_InitQuoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetQuoteResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetQuoteResponse) */ {
 public:
  Response_GetQuoteResponse();
  virtual ~Response_GetQuoteResponse();

  Response_GetQuoteResponse(const Response_GetQuoteResponse& from);

  inline Response_GetQuoteResponse& operator=(const Response_GetQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetQuoteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetQuoteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetQuoteResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetQuoteResponse* New() const { return New(NULL); }

  Response_GetQuoteResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetQuoteResponse& from);
  void MergeFrom(const Response_GetQuoteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetQuoteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes quote = 2;
  bool has_quote() const;
  void clear_quote();
  static const int kQuoteFieldNumber = 2;
  const ::std::string& quote() const;
  void set_quote(const ::std::string& value);
  void set_quote(const char* value);
  void set_quote(const void* value, size_t size);
  ::std::string* mutable_quote();
  ::std::string* release_quote();
  void set_allocated_quote(::std::string* quote);

  // optional bytes qe_report = 3;
  bool has_qe_report() const;
  void clear_qe_report();
  static const int kQeReportFieldNumber = 3;
  const ::std::string& qe_report() const;
  void set_qe_report(const ::std::string& value);
  void set_qe_report(const char* value);
  void set_qe_report(const void* value, size_t size);
  ::std::string* mutable_qe_report();
  ::std::string* release_qe_report();
  void set_allocated_qe_report(::std::string* qe_report);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetQuoteResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_quote();
  inline void clear_has_quote();
  inline void set_has_qe_report();
  inline void clear_has_qe_report();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr quote_;
  ::google::protobuf::internal::ArenaStringPtr qe_report_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetQuoteResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetLaunchTokenResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetLaunchTokenResponse) */ {
 public:
  Response_GetLaunchTokenResponse();
  virtual ~Response_GetLaunchTokenResponse();

  Response_GetLaunchTokenResponse(const Response_GetLaunchTokenResponse& from);

  inline Response_GetLaunchTokenResponse& operator=(const Response_GetLaunchTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetLaunchTokenResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetLaunchTokenResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetLaunchTokenResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetLaunchTokenResponse* New() const { return New(NULL); }

  Response_GetLaunchTokenResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetLaunchTokenResponse& from);
  void MergeFrom(const Response_GetLaunchTokenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetLaunchTokenResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetLaunchTokenResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetLaunchTokenResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_ReportAttestationErrorResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.ReportAttestationErrorResponse) */ {
 public:
  Response_ReportAttestationErrorResponse();
  virtual ~Response_ReportAttestationErrorResponse();

  Response_ReportAttestationErrorResponse(const Response_ReportAttestationErrorResponse& from);

  inline Response_ReportAttestationErrorResponse& operator=(const Response_ReportAttestationErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_ReportAttestationErrorResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_ReportAttestationErrorResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_ReportAttestationErrorResponse* other);

  // implements Message ----------------------------------------------

  inline Response_ReportAttestationErrorResponse* New() const { return New(NULL); }

  Response_ReportAttestationErrorResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_ReportAttestationErrorResponse& from);
  void MergeFrom(const Response_ReportAttestationErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_ReportAttestationErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes platform_update_info = 2;
  bool has_platform_update_info() const;
  void clear_platform_update_info();
  static const int kPlatformUpdateInfoFieldNumber = 2;
  const ::std::string& platform_update_info() const;
  void set_platform_update_info(const ::std::string& value);
  void set_platform_update_info(const char* value);
  void set_platform_update_info(const void* value, size_t size);
  ::std::string* mutable_platform_update_info();
  ::std::string* release_platform_update_info();
  void set_allocated_platform_update_info(::std::string* platform_update_info);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.ReportAttestationErrorResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_platform_update_info();
  inline void clear_has_platform_update_info();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr platform_update_info_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ReportAttestationErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_CheckUpdateStatusResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.CheckUpdateStatusResponse) */ {
 public:
  Response_CheckUpdateStatusResponse();
  virtual ~Response_CheckUpdateStatusResponse();

  Response_CheckUpdateStatusResponse(const Response_CheckUpdateStatusResponse& from);

  inline Response_CheckUpdateStatusResponse& operator=(const Response_CheckUpdateStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_CheckUpdateStatusResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_CheckUpdateStatusResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_CheckUpdateStatusResponse* other);

  // implements Message ----------------------------------------------

  inline Response_CheckUpdateStatusResponse* New() const { return New(NULL); }

  Response_CheckUpdateStatusResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_CheckUpdateStatusResponse& from);
  void MergeFrom(const Response_CheckUpdateStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_CheckUpdateStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes platform_update_info = 2;
  bool has_platform_update_info() const;
  void clear_platform_update_info();
  static const int kPlatformUpdateInfoFieldNumber = 2;
  const ::std::string& platform_update_info() const;
  void set_platform_update_info(const ::std::string& value);
  void set_platform_update_info(const char* value);
  void set_platform_update_info(const void* value, size_t size);
  ::std::string* mutable_platform_update_info();
  ::std::string* release_platform_update_info();
  void set_allocated_platform_update_info(::std::string* platform_update_info);

  // optional uint32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.CheckUpdateStatusResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_platform_update_info();
  inline void clear_has_platform_update_info();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr platform_update_info_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_CheckUpdateStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetWhiteListSizeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetWhiteListSizeResponse) */ {
 public:
  Response_GetWhiteListSizeResponse();
  virtual ~Response_GetWhiteListSizeResponse();

  Response_GetWhiteListSizeResponse(const Response_GetWhiteListSizeResponse& from);

  inline Response_GetWhiteListSizeResponse& operator=(const Response_GetWhiteListSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetWhiteListSizeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetWhiteListSizeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetWhiteListSizeResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetWhiteListSizeResponse* New() const { return New(NULL); }

  Response_GetWhiteListSizeResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetWhiteListSizeResponse& from);
  void MergeFrom(const Response_GetWhiteListSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetWhiteListSizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 white_list_size = 2;
  bool has_white_list_size() const;
  void clear_white_list_size();
  static const int kWhiteListSizeFieldNumber = 2;
  ::google::protobuf::uint32 white_list_size() const;
  void set_white_list_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetWhiteListSizeResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_white_list_size();
  inline void clear_has_white_list_size();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 white_list_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetWhiteListSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetWhiteListResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetWhiteListResponse) */ {
 public:
  Response_GetWhiteListResponse();
  virtual ~Response_GetWhiteListResponse();

  Response_GetWhiteListResponse(const Response_GetWhiteListResponse& from);

  inline Response_GetWhiteListResponse& operator=(const Response_GetWhiteListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetWhiteListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetWhiteListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetWhiteListResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetWhiteListResponse* New() const { return New(NULL); }

  Response_GetWhiteListResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetWhiteListResponse& from);
  void MergeFrom(const Response_GetWhiteListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetWhiteListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes white_list = 2;
  bool has_white_list() const;
  void clear_white_list();
  static const int kWhiteListFieldNumber = 2;
  const ::std::string& white_list() const;
  void set_white_list(const ::std::string& value);
  void set_white_list(const char* value);
  void set_white_list(const void* value, size_t size);
  ::std::string* mutable_white_list();
  ::std::string* release_white_list();
  void set_allocated_white_list(::std::string* white_list);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetWhiteListResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_white_list();
  inline void clear_has_white_list();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr white_list_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetWhiteListResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SGXGetExtendedEpidGroupIdResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse) */ {
 public:
  Response_SGXGetExtendedEpidGroupIdResponse();
  virtual ~Response_SGXGetExtendedEpidGroupIdResponse();

  Response_SGXGetExtendedEpidGroupIdResponse(const Response_SGXGetExtendedEpidGroupIdResponse& from);

  inline Response_SGXGetExtendedEpidGroupIdResponse& operator=(const Response_SGXGetExtendedEpidGroupIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_SGXGetExtendedEpidGroupIdResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_SGXGetExtendedEpidGroupIdResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_SGXGetExtendedEpidGroupIdResponse* other);

  // implements Message ----------------------------------------------

  inline Response_SGXGetExtendedEpidGroupIdResponse* New() const { return New(NULL); }

  Response_SGXGetExtendedEpidGroupIdResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_SGXGetExtendedEpidGroupIdResponse& from);
  void MergeFrom(const Response_SGXGetExtendedEpidGroupIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_SGXGetExtendedEpidGroupIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 x_group_id = 2;
  bool has_x_group_id() const;
  void clear_x_group_id();
  static const int kXGroupIdFieldNumber = 2;
  ::google::protobuf::uint32 x_group_id() const;
  void set_x_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_x_group_id();
  inline void clear_has_x_group_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 x_group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SGXGetExtendedEpidGroupIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SGXSwitchExtendedEpidGroupResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.SGXSwitchExtendedEpidGroupResponse) */ {
 public:
  Response_SGXSwitchExtendedEpidGroupResponse();
  virtual ~Response_SGXSwitchExtendedEpidGroupResponse();

  Response_SGXSwitchExtendedEpidGroupResponse(const Response_SGXSwitchExtendedEpidGroupResponse& from);

  inline Response_SGXSwitchExtendedEpidGroupResponse& operator=(const Response_SGXSwitchExtendedEpidGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_SGXSwitchExtendedEpidGroupResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_SGXSwitchExtendedEpidGroupResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_SGXSwitchExtendedEpidGroupResponse* other);

  // implements Message ----------------------------------------------

  inline Response_SGXSwitchExtendedEpidGroupResponse* New() const { return New(NULL); }

  Response_SGXSwitchExtendedEpidGroupResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_SGXSwitchExtendedEpidGroupResponse& from);
  void MergeFrom(const Response_SGXSwitchExtendedEpidGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_SGXSwitchExtendedEpidGroupResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SGXSwitchExtendedEpidGroupResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SGXSwitchExtendedEpidGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SGXRegisterResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.SGXRegisterResponse) */ {
 public:
  Response_SGXRegisterResponse();
  virtual ~Response_SGXRegisterResponse();

  Response_SGXRegisterResponse(const Response_SGXRegisterResponse& from);

  inline Response_SGXRegisterResponse& operator=(const Response_SGXRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_SGXRegisterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_SGXRegisterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_SGXRegisterResponse* other);

  // implements Message ----------------------------------------------

  inline Response_SGXRegisterResponse* New() const { return New(NULL); }

  Response_SGXRegisterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_SGXRegisterResponse& from);
  void MergeFrom(const Response_SGXRegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_SGXRegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SGXRegisterResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SGXRegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_SelectAttKeyIDResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.SelectAttKeyIDResponse) */ {
 public:
  Response_SelectAttKeyIDResponse();
  virtual ~Response_SelectAttKeyIDResponse();

  Response_SelectAttKeyIDResponse(const Response_SelectAttKeyIDResponse& from);

  inline Response_SelectAttKeyIDResponse& operator=(const Response_SelectAttKeyIDResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_SelectAttKeyIDResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_SelectAttKeyIDResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_SelectAttKeyIDResponse* other);

  // implements Message ----------------------------------------------

  inline Response_SelectAttKeyIDResponse* New() const { return New(NULL); }

  Response_SelectAttKeyIDResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_SelectAttKeyIDResponse& from);
  void MergeFrom(const Response_SelectAttKeyIDResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_SelectAttKeyIDResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes selected_att_key_id = 2;
  bool has_selected_att_key_id() const;
  void clear_selected_att_key_id();
  static const int kSelectedAttKeyIdFieldNumber = 2;
  const ::std::string& selected_att_key_id() const;
  void set_selected_att_key_id(const ::std::string& value);
  void set_selected_att_key_id(const char* value);
  void set_selected_att_key_id(const void* value, size_t size);
  ::std::string* mutable_selected_att_key_id();
  ::std::string* release_selected_att_key_id();
  void set_allocated_selected_att_key_id(::std::string* selected_att_key_id);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.SelectAttKeyIDResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_selected_att_key_id();
  inline void clear_has_selected_att_key_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr selected_att_key_id_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_SelectAttKeyIDResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_InitQuoteExResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.InitQuoteExResponse) */ {
 public:
  Response_InitQuoteExResponse();
  virtual ~Response_InitQuoteExResponse();

  Response_InitQuoteExResponse(const Response_InitQuoteExResponse& from);

  inline Response_InitQuoteExResponse& operator=(const Response_InitQuoteExResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_InitQuoteExResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_InitQuoteExResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_InitQuoteExResponse* other);

  // implements Message ----------------------------------------------

  inline Response_InitQuoteExResponse* New() const { return New(NULL); }

  Response_InitQuoteExResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_InitQuoteExResponse& from);
  void MergeFrom(const Response_InitQuoteExResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_InitQuoteExResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes target_info = 2;
  bool has_target_info() const;
  void clear_target_info();
  static const int kTargetInfoFieldNumber = 2;
  const ::std::string& target_info() const;
  void set_target_info(const ::std::string& value);
  void set_target_info(const char* value);
  void set_target_info(const void* value, size_t size);
  ::std::string* mutable_target_info();
  ::std::string* release_target_info();
  void set_allocated_target_info(::std::string* target_info);

  // optional uint64 pub_key_id_size = 3;
  bool has_pub_key_id_size() const;
  void clear_pub_key_id_size();
  static const int kPubKeyIdSizeFieldNumber = 3;
  ::google::protobuf::uint64 pub_key_id_size() const;
  void set_pub_key_id_size(::google::protobuf::uint64 value);

  // optional bytes pub_key_id = 4;
  bool has_pub_key_id() const;
  void clear_pub_key_id();
  static const int kPubKeyIdFieldNumber = 4;
  const ::std::string& pub_key_id() const;
  void set_pub_key_id(const ::std::string& value);
  void set_pub_key_id(const char* value);
  void set_pub_key_id(const void* value, size_t size);
  ::std::string* mutable_pub_key_id();
  ::std::string* release_pub_key_id();
  void set_allocated_pub_key_id(::std::string* pub_key_id);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.InitQuoteExResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_target_info();
  inline void clear_has_target_info();
  inline void set_has_pub_key_id_size();
  inline void clear_has_pub_key_id_size();
  inline void set_has_pub_key_id();
  inline void clear_has_pub_key_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr target_info_;
  ::google::protobuf::uint64 pub_key_id_size_;
  ::google::protobuf::internal::ArenaStringPtr pub_key_id_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_InitQuoteExResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetQuoteSizeExResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetQuoteSizeExResponse) */ {
 public:
  Response_GetQuoteSizeExResponse();
  virtual ~Response_GetQuoteSizeExResponse();

  Response_GetQuoteSizeExResponse(const Response_GetQuoteSizeExResponse& from);

  inline Response_GetQuoteSizeExResponse& operator=(const Response_GetQuoteSizeExResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetQuoteSizeExResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetQuoteSizeExResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetQuoteSizeExResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetQuoteSizeExResponse* New() const { return New(NULL); }

  Response_GetQuoteSizeExResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetQuoteSizeExResponse& from);
  void MergeFrom(const Response_GetQuoteSizeExResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetQuoteSizeExResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 quote_size = 2;
  bool has_quote_size() const;
  void clear_quote_size();
  static const int kQuoteSizeFieldNumber = 2;
  ::google::protobuf::uint32 quote_size() const;
  void set_quote_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetQuoteSizeExResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_quote_size();
  inline void clear_has_quote_size();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 quote_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetQuoteSizeExResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetQuoteExResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetQuoteExResponse) */ {
 public:
  Response_GetQuoteExResponse();
  virtual ~Response_GetQuoteExResponse();

  Response_GetQuoteExResponse(const Response_GetQuoteExResponse& from);

  inline Response_GetQuoteExResponse& operator=(const Response_GetQuoteExResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetQuoteExResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetQuoteExResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetQuoteExResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetQuoteExResponse* New() const { return New(NULL); }

  Response_GetQuoteExResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetQuoteExResponse& from);
  void MergeFrom(const Response_GetQuoteExResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetQuoteExResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes quote = 2;
  bool has_quote() const;
  void clear_quote();
  static const int kQuoteFieldNumber = 2;
  const ::std::string& quote() const;
  void set_quote(const ::std::string& value);
  void set_quote(const char* value);
  void set_quote(const void* value, size_t size);
  ::std::string* mutable_quote();
  ::std::string* release_quote();
  void set_allocated_quote(::std::string* quote);

  // optional bytes qe_report_info = 3;
  bool has_qe_report_info() const;
  void clear_qe_report_info();
  static const int kQeReportInfoFieldNumber = 3;
  const ::std::string& qe_report_info() const;
  void set_qe_report_info(const ::std::string& value);
  void set_qe_report_info(const char* value);
  void set_qe_report_info(const void* value, size_t size);
  ::std::string* mutable_qe_report_info();
  ::std::string* release_qe_report_info();
  void set_allocated_qe_report_info(::std::string* qe_report_info);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetQuoteExResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_quote();
  inline void clear_has_quote();
  inline void set_has_qe_report_info();
  inline void clear_has_qe_report_info();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr quote_;
  ::google::protobuf::internal::ArenaStringPtr qe_report_info_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetQuoteExResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_UnsupportedRequestResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.UnsupportedRequestResponse) */ {
 public:
  Response_UnsupportedRequestResponse();
  virtual ~Response_UnsupportedRequestResponse();

  Response_UnsupportedRequestResponse(const Response_UnsupportedRequestResponse& from);

  inline Response_UnsupportedRequestResponse& operator=(const Response_UnsupportedRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_UnsupportedRequestResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_UnsupportedRequestResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_UnsupportedRequestResponse* other);

  // implements Message ----------------------------------------------

  inline Response_UnsupportedRequestResponse* New() const { return New(NULL); }

  Response_UnsupportedRequestResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_UnsupportedRequestResponse& from);
  void MergeFrom(const Response_UnsupportedRequestResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_UnsupportedRequestResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.UnsupportedRequestResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_UnsupportedRequestResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetSupportedAttKeyIDNumResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetSupportedAttKeyIDNumResponse) */ {
 public:
  Response_GetSupportedAttKeyIDNumResponse();
  virtual ~Response_GetSupportedAttKeyIDNumResponse();

  Response_GetSupportedAttKeyIDNumResponse(const Response_GetSupportedAttKeyIDNumResponse& from);

  inline Response_GetSupportedAttKeyIDNumResponse& operator=(const Response_GetSupportedAttKeyIDNumResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetSupportedAttKeyIDNumResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetSupportedAttKeyIDNumResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetSupportedAttKeyIDNumResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetSupportedAttKeyIDNumResponse* New() const { return New(NULL); }

  Response_GetSupportedAttKeyIDNumResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetSupportedAttKeyIDNumResponse& from);
  void MergeFrom(const Response_GetSupportedAttKeyIDNumResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetSupportedAttKeyIDNumResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional uint32 att_key_id_num = 2;
  bool has_att_key_id_num() const;
  void clear_att_key_id_num();
  static const int kAttKeyIdNumFieldNumber = 2;
  ::google::protobuf::uint32 att_key_id_num() const;
  void set_att_key_id_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetSupportedAttKeyIDNumResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_att_key_id_num();
  inline void clear_has_att_key_id_num();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::uint32 att_key_id_num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetSupportedAttKeyIDNumResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_GetSupportedAttKeyIDsResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response.GetSupportedAttKeyIDsResponse) */ {
 public:
  Response_GetSupportedAttKeyIDsResponse();
  virtual ~Response_GetSupportedAttKeyIDsResponse();

  Response_GetSupportedAttKeyIDsResponse(const Response_GetSupportedAttKeyIDsResponse& from);

  inline Response_GetSupportedAttKeyIDsResponse& operator=(const Response_GetSupportedAttKeyIDsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response_GetSupportedAttKeyIDsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response_GetSupportedAttKeyIDsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response_GetSupportedAttKeyIDsResponse* other);

  // implements Message ----------------------------------------------

  inline Response_GetSupportedAttKeyIDsResponse* New() const { return New(NULL); }

  Response_GetSupportedAttKeyIDsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response_GetSupportedAttKeyIDsResponse& from);
  void MergeFrom(const Response_GetSupportedAttKeyIDsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_GetSupportedAttKeyIDsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errorCode = 1 [default = 1];
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 errorcode() const;
  void set_errorcode(::google::protobuf::uint32 value);

  // optional bytes att_key_ids = 2;
  bool has_att_key_ids() const;
  void clear_att_key_ids();
  static const int kAttKeyIdsFieldNumber = 2;
  const ::std::string& att_key_ids() const;
  void set_att_key_ids(const ::std::string& value);
  void set_att_key_ids(const char* value);
  void set_att_key_ids(const void* value, size_t size);
  ::std::string* mutable_att_key_ids();
  ::std::string* release_att_key_ids();
  void set_allocated_att_key_ids(::std::string* att_key_ids);

  // @@protoc_insertion_point(class_scope:aesm.message.Response.GetSupportedAttKeyIDsResponse)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_att_key_ids();
  inline void clear_has_att_key_ids();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr att_key_ids_;
  ::google::protobuf::uint32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_GetSupportedAttKeyIDsResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aesm.message.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Response& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Response_InitQuoteResponse InitQuoteResponse;
  typedef Response_GetQuoteResponse GetQuoteResponse;
  typedef Response_GetLaunchTokenResponse GetLaunchTokenResponse;
  typedef Response_ReportAttestationErrorResponse ReportAttestationErrorResponse;
  typedef Response_CheckUpdateStatusResponse CheckUpdateStatusResponse;
  typedef Response_GetWhiteListSizeResponse GetWhiteListSizeResponse;
  typedef Response_GetWhiteListResponse GetWhiteListResponse;
  typedef Response_SGXGetExtendedEpidGroupIdResponse SGXGetExtendedEpidGroupIdResponse;
  typedef Response_SGXSwitchExtendedEpidGroupResponse SGXSwitchExtendedEpidGroupResponse;
  typedef Response_SGXRegisterResponse SGXRegisterResponse;
  typedef Response_SelectAttKeyIDResponse SelectAttKeyIDResponse;
  typedef Response_InitQuoteExResponse InitQuoteExResponse;
  typedef Response_GetQuoteSizeExResponse GetQuoteSizeExResponse;
  typedef Response_GetQuoteExResponse GetQuoteExResponse;
  typedef Response_UnsupportedRequestResponse UnsupportedRequestResponse;
  typedef Response_GetSupportedAttKeyIDNumResponse GetSupportedAttKeyIDNumResponse;
  typedef Response_GetSupportedAttKeyIDsResponse GetSupportedAttKeyIDsResponse;

  // accessors -------------------------------------------------------

  // optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;
  bool has_initquoteres() const;
  void clear_initquoteres();
  static const int kInitQuoteResFieldNumber = 1;
  const ::aesm::message::Response_InitQuoteResponse& initquoteres() const;
  ::aesm::message::Response_InitQuoteResponse* mutable_initquoteres();
  ::aesm::message::Response_InitQuoteResponse* release_initquoteres();
  void set_allocated_initquoteres(::aesm::message::Response_InitQuoteResponse* initquoteres);

  // optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;
  bool has_getquoteres() const;
  void clear_getquoteres();
  static const int kGetQuoteResFieldNumber = 2;
  const ::aesm::message::Response_GetQuoteResponse& getquoteres() const;
  ::aesm::message::Response_GetQuoteResponse* mutable_getquoteres();
  ::aesm::message::Response_GetQuoteResponse* release_getquoteres();
  void set_allocated_getquoteres(::aesm::message::Response_GetQuoteResponse* getquoteres);

  // optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;
  bool has_getlictokenres() const;
  void clear_getlictokenres();
  static const int kGetLicTokenResFieldNumber = 3;
  const ::aesm::message::Response_GetLaunchTokenResponse& getlictokenres() const;
  ::aesm::message::Response_GetLaunchTokenResponse* mutable_getlictokenres();
  ::aesm::message::Response_GetLaunchTokenResponse* release_getlictokenres();
  void set_allocated_getlictokenres(::aesm::message::Response_GetLaunchTokenResponse* getlictokenres);

  // optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;
  bool has_reporterrres() const;
  void clear_reporterrres();
  static const int kReportErrResFieldNumber = 4;
  const ::aesm::message::Response_ReportAttestationErrorResponse& reporterrres() const;
  ::aesm::message::Response_ReportAttestationErrorResponse* mutable_reporterrres();
  ::aesm::message::Response_ReportAttestationErrorResponse* release_reporterrres();
  void set_allocated_reporterrres(::aesm::message::Response_ReportAttestationErrorResponse* reporterrres);

  // optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;
  bool has_getwhitelistsizeres() const;
  void clear_getwhitelistsizeres();
  static const int kGetWhiteListSizeResFieldNumber = 10;
  const ::aesm::message::Response_GetWhiteListSizeResponse& getwhitelistsizeres() const;
  ::aesm::message::Response_GetWhiteListSizeResponse* mutable_getwhitelistsizeres();
  ::aesm::message::Response_GetWhiteListSizeResponse* release_getwhitelistsizeres();
  void set_allocated_getwhitelistsizeres(::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres);

  // optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;
  bool has_getwhitelistres() const;
  void clear_getwhitelistres();
  static const int kGetWhiteListResFieldNumber = 11;
  const ::aesm::message::Response_GetWhiteListResponse& getwhitelistres() const;
  ::aesm::message::Response_GetWhiteListResponse* mutable_getwhitelistres();
  ::aesm::message::Response_GetWhiteListResponse* release_getwhitelistres();
  void set_allocated_getwhitelistres(::aesm::message::Response_GetWhiteListResponse* getwhitelistres);

  // optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;
  bool has_sgxgetextendedepidgroupidres() const;
  void clear_sgxgetextendedepidgroupidres();
  static const int kSgxGetExtendedEpidGroupIdResFieldNumber = 12;
  const ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse& sgxgetextendedepidgroupidres() const;
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* mutable_sgxgetextendedepidgroupidres();
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* release_sgxgetextendedepidgroupidres();
  void set_allocated_sgxgetextendedepidgroupidres(::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres);

  // optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;
  bool has_sgxswitchextendedepidgroupres() const;
  void clear_sgxswitchextendedepidgroupres();
  static const int kSgxSwitchExtendedEpidGroupResFieldNumber = 13;
  const ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse& sgxswitchextendedepidgroupres() const;
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* mutable_sgxswitchextendedepidgroupres();
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* release_sgxswitchextendedepidgroupres();
  void set_allocated_sgxswitchextendedepidgroupres(::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres);

  // optional .aesm.message.Response.SGXRegisterResponse sgxRegisterRes = 14;
  bool has_sgxregisterres() const;
  void clear_sgxregisterres();
  static const int kSgxRegisterResFieldNumber = 14;
  const ::aesm::message::Response_SGXRegisterResponse& sgxregisterres() const;
  ::aesm::message::Response_SGXRegisterResponse* mutable_sgxregisterres();
  ::aesm::message::Response_SGXRegisterResponse* release_sgxregisterres();
  void set_allocated_sgxregisterres(::aesm::message::Response_SGXRegisterResponse* sgxregisterres);

  // optional .aesm.message.Response.InitQuoteExResponse initQuoteExRes = 15;
  bool has_initquoteexres() const;
  void clear_initquoteexres();
  static const int kInitQuoteExResFieldNumber = 15;
  const ::aesm::message::Response_InitQuoteExResponse& initquoteexres() const;
  ::aesm::message::Response_InitQuoteExResponse* mutable_initquoteexres();
  ::aesm::message::Response_InitQuoteExResponse* release_initquoteexres();
  void set_allocated_initquoteexres(::aesm::message::Response_InitQuoteExResponse* initquoteexres);

  // optional .aesm.message.Response.GetQuoteSizeExResponse getQuoteSizeExRes = 16;
  bool has_getquotesizeexres() const;
  void clear_getquotesizeexres();
  static const int kGetQuoteSizeExResFieldNumber = 16;
  const ::aesm::message::Response_GetQuoteSizeExResponse& getquotesizeexres() const;
  ::aesm::message::Response_GetQuoteSizeExResponse* mutable_getquotesizeexres();
  ::aesm::message::Response_GetQuoteSizeExResponse* release_getquotesizeexres();
  void set_allocated_getquotesizeexres(::aesm::message::Response_GetQuoteSizeExResponse* getquotesizeexres);

  // optional .aesm.message.Response.GetQuoteExResponse getQuoteExRes = 17;
  bool has_getquoteexres() const;
  void clear_getquoteexres();
  static const int kGetQuoteExResFieldNumber = 17;
  const ::aesm::message::Response_GetQuoteExResponse& getquoteexres() const;
  ::aesm::message::Response_GetQuoteExResponse* mutable_getquoteexres();
  ::aesm::message::Response_GetQuoteExResponse* release_getquoteexres();
  void set_allocated_getquoteexres(::aesm::message::Response_GetQuoteExResponse* getquoteexres);

  // optional .aesm.message.Response.CheckUpdateStatusResponse checkUpdateStatusRes = 18;
  bool has_checkupdatestatusres() const;
  void clear_checkupdatestatusres();
  static const int kCheckUpdateStatusResFieldNumber = 18;
  const ::aesm::message::Response_CheckUpdateStatusResponse& checkupdatestatusres() const;
  ::aesm::message::Response_CheckUpdateStatusResponse* mutable_checkupdatestatusres();
  ::aesm::message::Response_CheckUpdateStatusResponse* release_checkupdatestatusres();
  void set_allocated_checkupdatestatusres(::aesm::message::Response_CheckUpdateStatusResponse* checkupdatestatusres);

  // optional .aesm.message.Response.SelectAttKeyIDResponse selectAttKeyIDRes = 19;
  bool has_selectattkeyidres() const;
  void clear_selectattkeyidres();
  static const int kSelectAttKeyIDResFieldNumber = 19;
  const ::aesm::message::Response_SelectAttKeyIDResponse& selectattkeyidres() const;
  ::aesm::message::Response_SelectAttKeyIDResponse* mutable_selectattkeyidres();
  ::aesm::message::Response_SelectAttKeyIDResponse* release_selectattkeyidres();
  void set_allocated_selectattkeyidres(::aesm::message::Response_SelectAttKeyIDResponse* selectattkeyidres);

  // optional .aesm.message.Response.UnsupportedRequestResponse unsupportedRequestResponse = 20;
  bool has_unsupportedrequestresponse() const;
  void clear_unsupportedrequestresponse();
  static const int kUnsupportedRequestResponseFieldNumber = 20;
  const ::aesm::message::Response_UnsupportedRequestResponse& unsupportedrequestresponse() const;
  ::aesm::message::Response_UnsupportedRequestResponse* mutable_unsupportedrequestresponse();
  ::aesm::message::Response_UnsupportedRequestResponse* release_unsupportedrequestresponse();
  void set_allocated_unsupportedrequestresponse(::aesm::message::Response_UnsupportedRequestResponse* unsupportedrequestresponse);

  // optional .aesm.message.Response.GetSupportedAttKeyIDNumResponse getSupportedAttKeyIDNumRes = 21;
  bool has_getsupportedattkeyidnumres() const;
  void clear_getsupportedattkeyidnumres();
  static const int kGetSupportedAttKeyIDNumResFieldNumber = 21;
  const ::aesm::message::Response_GetSupportedAttKeyIDNumResponse& getsupportedattkeyidnumres() const;
  ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* mutable_getsupportedattkeyidnumres();
  ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* release_getsupportedattkeyidnumres();
  void set_allocated_getsupportedattkeyidnumres(::aesm::message::Response_GetSupportedAttKeyIDNumResponse* getsupportedattkeyidnumres);

  // optional .aesm.message.Response.GetSupportedAttKeyIDsResponse getSupportedAttKeyIDsRes = 22;
  bool has_getsupportedattkeyidsres() const;
  void clear_getsupportedattkeyidsres();
  static const int kGetSupportedAttKeyIDsResFieldNumber = 22;
  const ::aesm::message::Response_GetSupportedAttKeyIDsResponse& getsupportedattkeyidsres() const;
  ::aesm::message::Response_GetSupportedAttKeyIDsResponse* mutable_getsupportedattkeyidsres();
  ::aesm::message::Response_GetSupportedAttKeyIDsResponse* release_getsupportedattkeyidsres();
  void set_allocated_getsupportedattkeyidsres(::aesm::message::Response_GetSupportedAttKeyIDsResponse* getsupportedattkeyidsres);

  // @@protoc_insertion_point(class_scope:aesm.message.Response)
 private:
  inline void set_has_initquoteres();
  inline void clear_has_initquoteres();
  inline void set_has_getquoteres();
  inline void clear_has_getquoteres();
  inline void set_has_getlictokenres();
  inline void clear_has_getlictokenres();
  inline void set_has_reporterrres();
  inline void clear_has_reporterrres();
  inline void set_has_getwhitelistsizeres();
  inline void clear_has_getwhitelistsizeres();
  inline void set_has_getwhitelistres();
  inline void clear_has_getwhitelistres();
  inline void set_has_sgxgetextendedepidgroupidres();
  inline void clear_has_sgxgetextendedepidgroupidres();
  inline void set_has_sgxswitchextendedepidgroupres();
  inline void clear_has_sgxswitchextendedepidgroupres();
  inline void set_has_sgxregisterres();
  inline void clear_has_sgxregisterres();
  inline void set_has_initquoteexres();
  inline void clear_has_initquoteexres();
  inline void set_has_getquotesizeexres();
  inline void clear_has_getquotesizeexres();
  inline void set_has_getquoteexres();
  inline void clear_has_getquoteexres();
  inline void set_has_checkupdatestatusres();
  inline void clear_has_checkupdatestatusres();
  inline void set_has_selectattkeyidres();
  inline void clear_has_selectattkeyidres();
  inline void set_has_unsupportedrequestresponse();
  inline void clear_has_unsupportedrequestresponse();
  inline void set_has_getsupportedattkeyidnumres();
  inline void clear_has_getsupportedattkeyidnumres();
  inline void set_has_getsupportedattkeyidsres();
  inline void clear_has_getsupportedattkeyidsres();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aesm::message::Response_InitQuoteResponse* initquoteres_;
  ::aesm::message::Response_GetQuoteResponse* getquoteres_;
  ::aesm::message::Response_GetLaunchTokenResponse* getlictokenres_;
  ::aesm::message::Response_ReportAttestationErrorResponse* reporterrres_;
  ::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres_;
  ::aesm::message::Response_GetWhiteListResponse* getwhitelistres_;
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres_;
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres_;
  ::aesm::message::Response_SGXRegisterResponse* sgxregisterres_;
  ::aesm::message::Response_InitQuoteExResponse* initquoteexres_;
  ::aesm::message::Response_GetQuoteSizeExResponse* getquotesizeexres_;
  ::aesm::message::Response_GetQuoteExResponse* getquoteexres_;
  ::aesm::message::Response_CheckUpdateStatusResponse* checkupdatestatusres_;
  ::aesm::message::Response_SelectAttKeyIDResponse* selectattkeyidres_;
  ::aesm::message::Response_UnsupportedRequestResponse* unsupportedrequestresponse_;
  ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* getsupportedattkeyidnumres_;
  ::aesm::message::Response_GetSupportedAttKeyIDsResponse* getsupportedattkeyidsres_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_messages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_messages_2eproto();
  #endif
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Request_InitQuoteRequest

// optional uint32 timeout = 9;
inline bool Request_InitQuoteRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_InitQuoteRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_InitQuoteRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_InitQuoteRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_InitQuoteRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.InitQuoteRequest.timeout)
  return timeout_;
}
inline void Request_InitQuoteRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.InitQuoteRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetQuoteRequest

// required bytes report = 1;
inline bool Request_GetQuoteRequest::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetQuoteRequest::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetQuoteRequest::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetQuoteRequest::clear_report() {
  report_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_report();
}
inline const ::std::string& Request_GetQuoteRequest::report() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.report)
  return report_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_report(const ::std::string& value) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.report)
}
inline void Request_GetQuoteRequest::set_report(const char* value) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteRequest.report)
}
inline void Request_GetQuoteRequest::set_report(const void* value, size_t size) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteRequest.report)
}
inline ::std::string* Request_GetQuoteRequest::mutable_report() {
  set_has_report();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteRequest.report)
  return report_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteRequest::release_report() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteRequest.report)
  clear_has_report();
  return report_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_allocated_report(::std::string* report) {
  if (report != NULL) {
    set_has_report();
  } else {
    clear_has_report();
  }
  report_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), report);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteRequest.report)
}

// required uint32 quote_type = 2;
inline bool Request_GetQuoteRequest::has_quote_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetQuoteRequest::set_has_quote_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetQuoteRequest::clear_has_quote_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetQuoteRequest::clear_quote_type() {
  quote_type_ = 0u;
  clear_has_quote_type();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::quote_type() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.quote_type)
  return quote_type_;
}
inline void Request_GetQuoteRequest::set_quote_type(::google::protobuf::uint32 value) {
  set_has_quote_type();
  quote_type_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.quote_type)
}

// required bytes spid = 3;
inline bool Request_GetQuoteRequest::has_spid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_GetQuoteRequest::set_has_spid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_GetQuoteRequest::clear_has_spid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_GetQuoteRequest::clear_spid() {
  spid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spid();
}
inline const ::std::string& Request_GetQuoteRequest::spid() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.spid)
  return spid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_spid(const ::std::string& value) {
  set_has_spid();
  spid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.spid)
}
inline void Request_GetQuoteRequest::set_spid(const char* value) {
  set_has_spid();
  spid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteRequest.spid)
}
inline void Request_GetQuoteRequest::set_spid(const void* value, size_t size) {
  set_has_spid();
  spid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteRequest.spid)
}
inline ::std::string* Request_GetQuoteRequest::mutable_spid() {
  set_has_spid();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteRequest.spid)
  return spid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteRequest::release_spid() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteRequest.spid)
  clear_has_spid();
  return spid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_allocated_spid(::std::string* spid) {
  if (spid != NULL) {
    set_has_spid();
  } else {
    clear_has_spid();
  }
  spid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spid);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteRequest.spid)
}

// optional bytes nonce = 4;
inline bool Request_GetQuoteRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_GetQuoteRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_GetQuoteRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_GetQuoteRequest::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
inline const ::std::string& Request_GetQuoteRequest::nonce() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.nonce)
  return nonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.nonce)
}
inline void Request_GetQuoteRequest::set_nonce(const char* value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteRequest.nonce)
}
inline void Request_GetQuoteRequest::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteRequest.nonce)
}
inline ::std::string* Request_GetQuoteRequest::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteRequest.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteRequest::release_nonce() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteRequest.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteRequest.nonce)
}

// optional bytes sig_rl = 5;
inline bool Request_GetQuoteRequest::has_sig_rl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_GetQuoteRequest::set_has_sig_rl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_GetQuoteRequest::clear_has_sig_rl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_GetQuoteRequest::clear_sig_rl() {
  sig_rl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sig_rl();
}
inline const ::std::string& Request_GetQuoteRequest::sig_rl() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.sig_rl)
  return sig_rl_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_sig_rl(const ::std::string& value) {
  set_has_sig_rl();
  sig_rl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.sig_rl)
}
inline void Request_GetQuoteRequest::set_sig_rl(const char* value) {
  set_has_sig_rl();
  sig_rl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteRequest.sig_rl)
}
inline void Request_GetQuoteRequest::set_sig_rl(const void* value, size_t size) {
  set_has_sig_rl();
  sig_rl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteRequest.sig_rl)
}
inline ::std::string* Request_GetQuoteRequest::mutable_sig_rl() {
  set_has_sig_rl();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteRequest.sig_rl)
  return sig_rl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteRequest::release_sig_rl() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteRequest.sig_rl)
  clear_has_sig_rl();
  return sig_rl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteRequest::set_allocated_sig_rl(::std::string* sig_rl) {
  if (sig_rl != NULL) {
    set_has_sig_rl();
  } else {
    clear_has_sig_rl();
  }
  sig_rl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig_rl);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteRequest.sig_rl)
}

// required uint32 buf_size = 6;
inline bool Request_GetQuoteRequest::has_buf_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_GetQuoteRequest::set_has_buf_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_GetQuoteRequest::clear_has_buf_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_GetQuoteRequest::clear_buf_size() {
  buf_size_ = 0u;
  clear_has_buf_size();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::buf_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.buf_size)
  return buf_size_;
}
inline void Request_GetQuoteRequest::set_buf_size(::google::protobuf::uint32 value) {
  set_has_buf_size();
  buf_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.buf_size)
}

// optional bool qe_report = 7;
inline bool Request_GetQuoteRequest::has_qe_report() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request_GetQuoteRequest::set_has_qe_report() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request_GetQuoteRequest::clear_has_qe_report() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request_GetQuoteRequest::clear_qe_report() {
  qe_report_ = false;
  clear_has_qe_report();
}
inline bool Request_GetQuoteRequest::qe_report() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.qe_report)
  return qe_report_;
}
inline void Request_GetQuoteRequest::set_qe_report(bool value) {
  set_has_qe_report();
  qe_report_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.qe_report)
}

// optional uint32 timeout = 9;
inline bool Request_GetQuoteRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request_GetQuoteRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request_GetQuoteRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request_GetQuoteRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetQuoteRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteRequest.timeout)
  return timeout_;
}
inline void Request_GetQuoteRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetLaunchTokenRequest

// required bytes mr_enclave = 1;
inline bool Request_GetLaunchTokenRequest::has_mr_enclave() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_mr_enclave() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetLaunchTokenRequest::clear_has_mr_enclave() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetLaunchTokenRequest::clear_mr_enclave() {
  mr_enclave_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mr_enclave();
}
inline const ::std::string& Request_GetLaunchTokenRequest::mr_enclave() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
  return mr_enclave_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const ::std::string& value) {
  set_has_mr_enclave();
  mr_enclave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const char* value) {
  set_has_mr_enclave();
  mr_enclave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
}
inline void Request_GetLaunchTokenRequest::set_mr_enclave(const void* value, size_t size) {
  set_has_mr_enclave();
  mr_enclave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_mr_enclave() {
  set_has_mr_enclave();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
  return mr_enclave_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetLaunchTokenRequest::release_mr_enclave() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
  clear_has_mr_enclave();
  return mr_enclave_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_allocated_mr_enclave(::std::string* mr_enclave) {
  if (mr_enclave != NULL) {
    set_has_mr_enclave();
  } else {
    clear_has_mr_enclave();
  }
  mr_enclave_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mr_enclave);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetLaunchTokenRequest.mr_enclave)
}

// required bytes mr_signer = 2;
inline bool Request_GetLaunchTokenRequest::has_mr_signer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_mr_signer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetLaunchTokenRequest::clear_has_mr_signer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetLaunchTokenRequest::clear_mr_signer() {
  mr_signer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mr_signer();
}
inline const ::std::string& Request_GetLaunchTokenRequest::mr_signer() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
  return mr_signer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const ::std::string& value) {
  set_has_mr_signer();
  mr_signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const char* value) {
  set_has_mr_signer();
  mr_signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
}
inline void Request_GetLaunchTokenRequest::set_mr_signer(const void* value, size_t size) {
  set_has_mr_signer();
  mr_signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_mr_signer() {
  set_has_mr_signer();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
  return mr_signer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetLaunchTokenRequest::release_mr_signer() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
  clear_has_mr_signer();
  return mr_signer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_allocated_mr_signer(::std::string* mr_signer) {
  if (mr_signer != NULL) {
    set_has_mr_signer();
  } else {
    clear_has_mr_signer();
  }
  mr_signer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mr_signer);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetLaunchTokenRequest.mr_signer)
}

// required bytes se_attributes = 3;
inline bool Request_GetLaunchTokenRequest::has_se_attributes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_se_attributes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_GetLaunchTokenRequest::clear_has_se_attributes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_GetLaunchTokenRequest::clear_se_attributes() {
  se_attributes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_se_attributes();
}
inline const ::std::string& Request_GetLaunchTokenRequest::se_attributes() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
  return se_attributes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const ::std::string& value) {
  set_has_se_attributes();
  se_attributes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const char* value) {
  set_has_se_attributes();
  se_attributes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
}
inline void Request_GetLaunchTokenRequest::set_se_attributes(const void* value, size_t size) {
  set_has_se_attributes();
  se_attributes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
}
inline ::std::string* Request_GetLaunchTokenRequest::mutable_se_attributes() {
  set_has_se_attributes();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
  return se_attributes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetLaunchTokenRequest::release_se_attributes() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
  clear_has_se_attributes();
  return se_attributes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetLaunchTokenRequest::set_allocated_se_attributes(::std::string* se_attributes) {
  if (se_attributes != NULL) {
    set_has_se_attributes();
  } else {
    clear_has_se_attributes();
  }
  se_attributes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), se_attributes);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetLaunchTokenRequest.se_attributes)
}

// optional uint32 timeout = 9;
inline bool Request_GetLaunchTokenRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_GetLaunchTokenRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_GetLaunchTokenRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_GetLaunchTokenRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetLaunchTokenRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetLaunchTokenRequest.timeout)
  return timeout_;
}
inline void Request_GetLaunchTokenRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetLaunchTokenRequest.timeout)
}

// -------------------------------------------------------------------

// Request_ReportAttestationErrorRequest

// required bytes platform_info = 1;
inline bool Request_ReportAttestationErrorRequest::has_platform_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_platform_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_platform_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_ReportAttestationErrorRequest::clear_platform_info() {
  platform_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform_info();
}
inline const ::std::string& Request_ReportAttestationErrorRequest::platform_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
  return platform_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const ::std::string& value) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const char* value) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
}
inline void Request_ReportAttestationErrorRequest::set_platform_info(const void* value, size_t size) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
}
inline ::std::string* Request_ReportAttestationErrorRequest::mutable_platform_info() {
  set_has_platform_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
  return platform_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_ReportAttestationErrorRequest::release_platform_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
  clear_has_platform_info();
  return platform_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_ReportAttestationErrorRequest::set_allocated_platform_info(::std::string* platform_info) {
  if (platform_info != NULL) {
    set_has_platform_info();
  } else {
    clear_has_platform_info();
  }
  platform_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.ReportAttestationErrorRequest.platform_info)
}

// required uint32 attestation_error_code = 2;
inline bool Request_ReportAttestationErrorRequest::has_attestation_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_attestation_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_attestation_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_ReportAttestationErrorRequest::clear_attestation_error_code() {
  attestation_error_code_ = 0u;
  clear_has_attestation_error_code();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::attestation_error_code() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.ReportAttestationErrorRequest.attestation_error_code)
  return attestation_error_code_;
}
inline void Request_ReportAttestationErrorRequest::set_attestation_error_code(::google::protobuf::uint32 value) {
  set_has_attestation_error_code();
  attestation_error_code_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.ReportAttestationErrorRequest.attestation_error_code)
}

// required uint32 update_info_size = 3;
inline bool Request_ReportAttestationErrorRequest::has_update_info_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_update_info_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_update_info_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_ReportAttestationErrorRequest::clear_update_info_size() {
  update_info_size_ = 0u;
  clear_has_update_info_size();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::update_info_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.ReportAttestationErrorRequest.update_info_size)
  return update_info_size_;
}
inline void Request_ReportAttestationErrorRequest::set_update_info_size(::google::protobuf::uint32 value) {
  set_has_update_info_size();
  update_info_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.ReportAttestationErrorRequest.update_info_size)
}

// optional uint32 timeout = 9;
inline bool Request_ReportAttestationErrorRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_ReportAttestationErrorRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_ReportAttestationErrorRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_ReportAttestationErrorRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_ReportAttestationErrorRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.ReportAttestationErrorRequest.timeout)
  return timeout_;
}
inline void Request_ReportAttestationErrorRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.ReportAttestationErrorRequest.timeout)
}

// -------------------------------------------------------------------

// Request_CheckUpdateStatusRequest

// optional bytes platform_info = 1;
inline bool Request_CheckUpdateStatusRequest::has_platform_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_CheckUpdateStatusRequest::set_has_platform_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_CheckUpdateStatusRequest::clear_has_platform_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_CheckUpdateStatusRequest::clear_platform_info() {
  platform_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform_info();
}
inline const ::std::string& Request_CheckUpdateStatusRequest::platform_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
  return platform_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_CheckUpdateStatusRequest::set_platform_info(const ::std::string& value) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
}
inline void Request_CheckUpdateStatusRequest::set_platform_info(const char* value) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
}
inline void Request_CheckUpdateStatusRequest::set_platform_info(const void* value, size_t size) {
  set_has_platform_info();
  platform_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
}
inline ::std::string* Request_CheckUpdateStatusRequest::mutable_platform_info() {
  set_has_platform_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
  return platform_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_CheckUpdateStatusRequest::release_platform_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
  clear_has_platform_info();
  return platform_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_CheckUpdateStatusRequest::set_allocated_platform_info(::std::string* platform_info) {
  if (platform_info != NULL) {
    set_has_platform_info();
  } else {
    clear_has_platform_info();
  }
  platform_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.CheckUpdateStatusRequest.platform_info)
}

// required uint32 update_info_size = 2;
inline bool Request_CheckUpdateStatusRequest::has_update_info_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_CheckUpdateStatusRequest::set_has_update_info_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_CheckUpdateStatusRequest::clear_has_update_info_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_CheckUpdateStatusRequest::clear_update_info_size() {
  update_info_size_ = 0u;
  clear_has_update_info_size();
}
inline ::google::protobuf::uint32 Request_CheckUpdateStatusRequest::update_info_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.CheckUpdateStatusRequest.update_info_size)
  return update_info_size_;
}
inline void Request_CheckUpdateStatusRequest::set_update_info_size(::google::protobuf::uint32 value) {
  set_has_update_info_size();
  update_info_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.CheckUpdateStatusRequest.update_info_size)
}

// required uint32 config = 3;
inline bool Request_CheckUpdateStatusRequest::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_CheckUpdateStatusRequest::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_CheckUpdateStatusRequest::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_CheckUpdateStatusRequest::clear_config() {
  config_ = 0u;
  clear_has_config();
}
inline ::google::protobuf::uint32 Request_CheckUpdateStatusRequest::config() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.CheckUpdateStatusRequest.config)
  return config_;
}
inline void Request_CheckUpdateStatusRequest::set_config(::google::protobuf::uint32 value) {
  set_has_config();
  config_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.CheckUpdateStatusRequest.config)
}

// optional uint32 timeout = 9;
inline bool Request_CheckUpdateStatusRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_CheckUpdateStatusRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_CheckUpdateStatusRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_CheckUpdateStatusRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_CheckUpdateStatusRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.CheckUpdateStatusRequest.timeout)
  return timeout_;
}
inline void Request_CheckUpdateStatusRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.CheckUpdateStatusRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetWhiteListSizeRequest

// optional uint32 timeout = 9;
inline bool Request_GetWhiteListSizeRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetWhiteListSizeRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetWhiteListSizeRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetWhiteListSizeRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetWhiteListSizeRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetWhiteListSizeRequest.timeout)
  return timeout_;
}
inline void Request_GetWhiteListSizeRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetWhiteListSizeRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetWhiteListRequest

// optional uint32 white_list_size = 1;
inline bool Request_GetWhiteListRequest::has_white_list_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetWhiteListRequest::set_has_white_list_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetWhiteListRequest::clear_has_white_list_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetWhiteListRequest::clear_white_list_size() {
  white_list_size_ = 0u;
  clear_has_white_list_size();
}
inline ::google::protobuf::uint32 Request_GetWhiteListRequest::white_list_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetWhiteListRequest.white_list_size)
  return white_list_size_;
}
inline void Request_GetWhiteListRequest::set_white_list_size(::google::protobuf::uint32 value) {
  set_has_white_list_size();
  white_list_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetWhiteListRequest.white_list_size)
}

// optional uint32 timeout = 9;
inline bool Request_GetWhiteListRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetWhiteListRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetWhiteListRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetWhiteListRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetWhiteListRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetWhiteListRequest.timeout)
  return timeout_;
}
inline void Request_GetWhiteListRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetWhiteListRequest.timeout)
}

// -------------------------------------------------------------------

// Request_SGXGetExtendedEpidGroupIdRequest

// optional uint32 timeout = 9;
inline bool Request_SGXGetExtendedEpidGroupIdRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SGXGetExtendedEpidGroupIdRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXGetExtendedEpidGroupIdRequest.timeout)
  return timeout_;
}
inline void Request_SGXGetExtendedEpidGroupIdRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXGetExtendedEpidGroupIdRequest.timeout)
}

// -------------------------------------------------------------------

// Request_SGXSwitchExtendedEpidGroupRequest

// optional uint32 x_group_id = 1;
inline bool Request_SGXSwitchExtendedEpidGroupRequest::has_x_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_has_x_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_has_x_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_x_group_id() {
  x_group_id_ = 0u;
  clear_has_x_group_id();
}
inline ::google::protobuf::uint32 Request_SGXSwitchExtendedEpidGroupRequest::x_group_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest.x_group_id)
  return x_group_id_;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_x_group_id(::google::protobuf::uint32 value) {
  set_has_x_group_id();
  x_group_id_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest.x_group_id)
}

// optional uint32 timeout = 9;
inline bool Request_SGXSwitchExtendedEpidGroupRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SGXSwitchExtendedEpidGroupRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest.timeout)
  return timeout_;
}
inline void Request_SGXSwitchExtendedEpidGroupRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXSwitchExtendedEpidGroupRequest.timeout)
}

// -------------------------------------------------------------------

// Request_SGXRegisterRequest

// required bytes buf = 1;
inline bool Request_SGXRegisterRequest::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SGXRegisterRequest::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SGXRegisterRequest::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SGXRegisterRequest::clear_buf() {
  buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buf();
}
inline const ::std::string& Request_SGXRegisterRequest::buf() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXRegisterRequest.buf)
  return buf_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_SGXRegisterRequest::set_buf(const ::std::string& value) {
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXRegisterRequest.buf)
}
inline void Request_SGXRegisterRequest::set_buf(const char* value) {
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.SGXRegisterRequest.buf)
}
inline void Request_SGXRegisterRequest::set_buf(const void* value, size_t size) {
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.SGXRegisterRequest.buf)
}
inline ::std::string* Request_SGXRegisterRequest::mutable_buf() {
  set_has_buf();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.SGXRegisterRequest.buf)
  return buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_SGXRegisterRequest::release_buf() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.SGXRegisterRequest.buf)
  clear_has_buf();
  return buf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_SGXRegisterRequest::set_allocated_buf(::std::string* buf) {
  if (buf != NULL) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buf);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.SGXRegisterRequest.buf)
}

// required uint32 data_type = 2;
inline bool Request_SGXRegisterRequest::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_SGXRegisterRequest::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_SGXRegisterRequest::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_SGXRegisterRequest::clear_data_type() {
  data_type_ = 0u;
  clear_has_data_type();
}
inline ::google::protobuf::uint32 Request_SGXRegisterRequest::data_type() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXRegisterRequest.data_type)
  return data_type_;
}
inline void Request_SGXRegisterRequest::set_data_type(::google::protobuf::uint32 value) {
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXRegisterRequest.data_type)
}

// optional uint32 timeout = 9;
inline bool Request_SGXRegisterRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_SGXRegisterRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_SGXRegisterRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_SGXRegisterRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SGXRegisterRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SGXRegisterRequest.timeout)
  return timeout_;
}
inline void Request_SGXRegisterRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SGXRegisterRequest.timeout)
}

// -------------------------------------------------------------------

// Request_InitQuoteExRequest

// optional bytes att_key_id = 1;
inline bool Request_InitQuoteExRequest::has_att_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_InitQuoteExRequest::set_has_att_key_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_InitQuoteExRequest::clear_has_att_key_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_InitQuoteExRequest::clear_att_key_id() {
  att_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_att_key_id();
}
inline const ::std::string& Request_InitQuoteExRequest::att_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.InitQuoteExRequest.att_key_id)
  return att_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_InitQuoteExRequest::set_att_key_id(const ::std::string& value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.InitQuoteExRequest.att_key_id)
}
inline void Request_InitQuoteExRequest::set_att_key_id(const char* value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.InitQuoteExRequest.att_key_id)
}
inline void Request_InitQuoteExRequest::set_att_key_id(const void* value, size_t size) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.InitQuoteExRequest.att_key_id)
}
inline ::std::string* Request_InitQuoteExRequest::mutable_att_key_id() {
  set_has_att_key_id();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.InitQuoteExRequest.att_key_id)
  return att_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_InitQuoteExRequest::release_att_key_id() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.InitQuoteExRequest.att_key_id)
  clear_has_att_key_id();
  return att_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_InitQuoteExRequest::set_allocated_att_key_id(::std::string* att_key_id) {
  if (att_key_id != NULL) {
    set_has_att_key_id();
  } else {
    clear_has_att_key_id();
  }
  att_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), att_key_id);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.InitQuoteExRequest.att_key_id)
}

// required bool b_pub_key_id = 3;
inline bool Request_InitQuoteExRequest::has_b_pub_key_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_InitQuoteExRequest::set_has_b_pub_key_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_InitQuoteExRequest::clear_has_b_pub_key_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_InitQuoteExRequest::clear_b_pub_key_id() {
  b_pub_key_id_ = false;
  clear_has_b_pub_key_id();
}
inline bool Request_InitQuoteExRequest::b_pub_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.InitQuoteExRequest.b_pub_key_id)
  return b_pub_key_id_;
}
inline void Request_InitQuoteExRequest::set_b_pub_key_id(bool value) {
  set_has_b_pub_key_id();
  b_pub_key_id_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.InitQuoteExRequest.b_pub_key_id)
}

// optional uint64 buf_size = 4;
inline bool Request_InitQuoteExRequest::has_buf_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_InitQuoteExRequest::set_has_buf_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_InitQuoteExRequest::clear_has_buf_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_InitQuoteExRequest::clear_buf_size() {
  buf_size_ = GOOGLE_ULONGLONG(0);
  clear_has_buf_size();
}
inline ::google::protobuf::uint64 Request_InitQuoteExRequest::buf_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.InitQuoteExRequest.buf_size)
  return buf_size_;
}
inline void Request_InitQuoteExRequest::set_buf_size(::google::protobuf::uint64 value) {
  set_has_buf_size();
  buf_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.InitQuoteExRequest.buf_size)
}

// optional uint32 timeout = 9;
inline bool Request_InitQuoteExRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_InitQuoteExRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_InitQuoteExRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_InitQuoteExRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_InitQuoteExRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.InitQuoteExRequest.timeout)
  return timeout_;
}
inline void Request_InitQuoteExRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.InitQuoteExRequest.timeout)
}

// -------------------------------------------------------------------

// Request_SelectAttKeyIDRequest

// optional bytes att_key_id_list = 1;
inline bool Request_SelectAttKeyIDRequest::has_att_key_id_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_SelectAttKeyIDRequest::set_has_att_key_id_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_SelectAttKeyIDRequest::clear_has_att_key_id_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_SelectAttKeyIDRequest::clear_att_key_id_list() {
  att_key_id_list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_att_key_id_list();
}
inline const ::std::string& Request_SelectAttKeyIDRequest::att_key_id_list() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
  return att_key_id_list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_SelectAttKeyIDRequest::set_att_key_id_list(const ::std::string& value) {
  set_has_att_key_id_list();
  att_key_id_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
}
inline void Request_SelectAttKeyIDRequest::set_att_key_id_list(const char* value) {
  set_has_att_key_id_list();
  att_key_id_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
}
inline void Request_SelectAttKeyIDRequest::set_att_key_id_list(const void* value, size_t size) {
  set_has_att_key_id_list();
  att_key_id_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
}
inline ::std::string* Request_SelectAttKeyIDRequest::mutable_att_key_id_list() {
  set_has_att_key_id_list();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
  return att_key_id_list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_SelectAttKeyIDRequest::release_att_key_id_list() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
  clear_has_att_key_id_list();
  return att_key_id_list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_SelectAttKeyIDRequest::set_allocated_att_key_id_list(::std::string* att_key_id_list) {
  if (att_key_id_list != NULL) {
    set_has_att_key_id_list();
  } else {
    clear_has_att_key_id_list();
  }
  att_key_id_list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), att_key_id_list);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.SelectAttKeyIDRequest.att_key_id_list)
}

// optional uint32 timeout = 2;
inline bool Request_SelectAttKeyIDRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_SelectAttKeyIDRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_SelectAttKeyIDRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_SelectAttKeyIDRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_SelectAttKeyIDRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.SelectAttKeyIDRequest.timeout)
  return timeout_;
}
inline void Request_SelectAttKeyIDRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.SelectAttKeyIDRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetQuoteSizeExRequest

// optional bytes att_key_id = 1;
inline bool Request_GetQuoteSizeExRequest::has_att_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetQuoteSizeExRequest::set_has_att_key_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetQuoteSizeExRequest::clear_has_att_key_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetQuoteSizeExRequest::clear_att_key_id() {
  att_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_att_key_id();
}
inline const ::std::string& Request_GetQuoteSizeExRequest::att_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
  return att_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteSizeExRequest::set_att_key_id(const ::std::string& value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
}
inline void Request_GetQuoteSizeExRequest::set_att_key_id(const char* value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
}
inline void Request_GetQuoteSizeExRequest::set_att_key_id(const void* value, size_t size) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
}
inline ::std::string* Request_GetQuoteSizeExRequest::mutable_att_key_id() {
  set_has_att_key_id();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
  return att_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteSizeExRequest::release_att_key_id() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
  clear_has_att_key_id();
  return att_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteSizeExRequest::set_allocated_att_key_id(::std::string* att_key_id) {
  if (att_key_id != NULL) {
    set_has_att_key_id();
  } else {
    clear_has_att_key_id();
  }
  att_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), att_key_id);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteSizeExRequest.att_key_id)
}

// optional uint32 timeout = 9;
inline bool Request_GetQuoteSizeExRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetQuoteSizeExRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetQuoteSizeExRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetQuoteSizeExRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetQuoteSizeExRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteSizeExRequest.timeout)
  return timeout_;
}
inline void Request_GetQuoteSizeExRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteSizeExRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetQuoteExRequest

// required bytes report = 1;
inline bool Request_GetQuoteExRequest::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetQuoteExRequest::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetQuoteExRequest::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetQuoteExRequest::clear_report() {
  report_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_report();
}
inline const ::std::string& Request_GetQuoteExRequest::report() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteExRequest.report)
  return report_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_report(const ::std::string& value) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteExRequest.report)
}
inline void Request_GetQuoteExRequest::set_report(const char* value) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteExRequest.report)
}
inline void Request_GetQuoteExRequest::set_report(const void* value, size_t size) {
  set_has_report();
  report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteExRequest.report)
}
inline ::std::string* Request_GetQuoteExRequest::mutable_report() {
  set_has_report();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteExRequest.report)
  return report_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteExRequest::release_report() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteExRequest.report)
  clear_has_report();
  return report_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_allocated_report(::std::string* report) {
  if (report != NULL) {
    set_has_report();
  } else {
    clear_has_report();
  }
  report_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), report);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteExRequest.report)
}

// optional bytes att_key_id = 2;
inline bool Request_GetQuoteExRequest::has_att_key_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetQuoteExRequest::set_has_att_key_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetQuoteExRequest::clear_has_att_key_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetQuoteExRequest::clear_att_key_id() {
  att_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_att_key_id();
}
inline const ::std::string& Request_GetQuoteExRequest::att_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteExRequest.att_key_id)
  return att_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_att_key_id(const ::std::string& value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteExRequest.att_key_id)
}
inline void Request_GetQuoteExRequest::set_att_key_id(const char* value) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteExRequest.att_key_id)
}
inline void Request_GetQuoteExRequest::set_att_key_id(const void* value, size_t size) {
  set_has_att_key_id();
  att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteExRequest.att_key_id)
}
inline ::std::string* Request_GetQuoteExRequest::mutable_att_key_id() {
  set_has_att_key_id();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteExRequest.att_key_id)
  return att_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteExRequest::release_att_key_id() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteExRequest.att_key_id)
  clear_has_att_key_id();
  return att_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_allocated_att_key_id(::std::string* att_key_id) {
  if (att_key_id != NULL) {
    set_has_att_key_id();
  } else {
    clear_has_att_key_id();
  }
  att_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), att_key_id);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteExRequest.att_key_id)
}

// optional bytes qe_report_info = 3;
inline bool Request_GetQuoteExRequest::has_qe_report_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_GetQuoteExRequest::set_has_qe_report_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_GetQuoteExRequest::clear_has_qe_report_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_GetQuoteExRequest::clear_qe_report_info() {
  qe_report_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qe_report_info();
}
inline const ::std::string& Request_GetQuoteExRequest::qe_report_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteExRequest.qe_report_info)
  return qe_report_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_qe_report_info(const ::std::string& value) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteExRequest.qe_report_info)
}
inline void Request_GetQuoteExRequest::set_qe_report_info(const char* value) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Request.GetQuoteExRequest.qe_report_info)
}
inline void Request_GetQuoteExRequest::set_qe_report_info(const void* value, size_t size) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Request.GetQuoteExRequest.qe_report_info)
}
inline ::std::string* Request_GetQuoteExRequest::mutable_qe_report_info() {
  set_has_qe_report_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.GetQuoteExRequest.qe_report_info)
  return qe_report_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_GetQuoteExRequest::release_qe_report_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.GetQuoteExRequest.qe_report_info)
  clear_has_qe_report_info();
  return qe_report_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_GetQuoteExRequest::set_allocated_qe_report_info(::std::string* qe_report_info) {
  if (qe_report_info != NULL) {
    set_has_qe_report_info();
  } else {
    clear_has_qe_report_info();
  }
  qe_report_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qe_report_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.GetQuoteExRequest.qe_report_info)
}

// required uint32 buf_size = 4;
inline bool Request_GetQuoteExRequest::has_buf_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_GetQuoteExRequest::set_has_buf_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_GetQuoteExRequest::clear_has_buf_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_GetQuoteExRequest::clear_buf_size() {
  buf_size_ = 0u;
  clear_has_buf_size();
}
inline ::google::protobuf::uint32 Request_GetQuoteExRequest::buf_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteExRequest.buf_size)
  return buf_size_;
}
inline void Request_GetQuoteExRequest::set_buf_size(::google::protobuf::uint32 value) {
  set_has_buf_size();
  buf_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteExRequest.buf_size)
}

// optional uint32 timeout = 9;
inline bool Request_GetQuoteExRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_GetQuoteExRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_GetQuoteExRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_GetQuoteExRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetQuoteExRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetQuoteExRequest.timeout)
  return timeout_;
}
inline void Request_GetQuoteExRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetQuoteExRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetSupportedAttKeyIDNumRequest

// optional uint32 timeout = 9;
inline bool Request_GetSupportedAttKeyIDNumRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetSupportedAttKeyIDNumRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetSupportedAttKeyIDNumRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetSupportedAttKeyIDNumRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetSupportedAttKeyIDNumRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetSupportedAttKeyIDNumRequest.timeout)
  return timeout_;
}
inline void Request_GetSupportedAttKeyIDNumRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetSupportedAttKeyIDNumRequest.timeout)
}

// -------------------------------------------------------------------

// Request_GetSupportedAttKeyIDsRequest

// required uint32 buf_size = 1;
inline bool Request_GetSupportedAttKeyIDsRequest::has_buf_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_GetSupportedAttKeyIDsRequest::set_has_buf_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_GetSupportedAttKeyIDsRequest::clear_has_buf_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_GetSupportedAttKeyIDsRequest::clear_buf_size() {
  buf_size_ = 0u;
  clear_has_buf_size();
}
inline ::google::protobuf::uint32 Request_GetSupportedAttKeyIDsRequest::buf_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetSupportedAttKeyIDsRequest.buf_size)
  return buf_size_;
}
inline void Request_GetSupportedAttKeyIDsRequest::set_buf_size(::google::protobuf::uint32 value) {
  set_has_buf_size();
  buf_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetSupportedAttKeyIDsRequest.buf_size)
}

// optional uint32 timeout = 9;
inline bool Request_GetSupportedAttKeyIDsRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_GetSupportedAttKeyIDsRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_GetSupportedAttKeyIDsRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_GetSupportedAttKeyIDsRequest::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 Request_GetSupportedAttKeyIDsRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.GetSupportedAttKeyIDsRequest.timeout)
  return timeout_;
}
inline void Request_GetSupportedAttKeyIDsRequest::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Request.GetSupportedAttKeyIDsRequest.timeout)
}

// -------------------------------------------------------------------

// Request

// optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;
inline bool Request::has_initquotereq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_initquotereq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_initquotereq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_initquotereq() {
  if (initquotereq_ != NULL) initquotereq_->::aesm::message::Request_InitQuoteRequest::Clear();
  clear_has_initquotereq();
}
inline const ::aesm::message::Request_InitQuoteRequest& Request::initquotereq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.initQuoteReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initquotereq_ != NULL ? *initquotereq_ : *default_instance().initquotereq_;
#else
  return initquotereq_ != NULL ? *initquotereq_ : *default_instance_->initquotereq_;
#endif
}
inline ::aesm::message::Request_InitQuoteRequest* Request::mutable_initquotereq() {
  set_has_initquotereq();
  if (initquotereq_ == NULL) {
    initquotereq_ = new ::aesm::message::Request_InitQuoteRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.initQuoteReq)
  return initquotereq_;
}
inline ::aesm::message::Request_InitQuoteRequest* Request::release_initquotereq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.initQuoteReq)
  clear_has_initquotereq();
  ::aesm::message::Request_InitQuoteRequest* temp = initquotereq_;
  initquotereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_initquotereq(::aesm::message::Request_InitQuoteRequest* initquotereq) {
  delete initquotereq_;
  initquotereq_ = initquotereq;
  if (initquotereq) {
    set_has_initquotereq();
  } else {
    clear_has_initquotereq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.initQuoteReq)
}

// optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;
inline bool Request::has_getquotereq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_getquotereq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_getquotereq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_getquotereq() {
  if (getquotereq_ != NULL) getquotereq_->::aesm::message::Request_GetQuoteRequest::Clear();
  clear_has_getquotereq();
}
inline const ::aesm::message::Request_GetQuoteRequest& Request::getquotereq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getQuoteReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquotereq_ != NULL ? *getquotereq_ : *default_instance().getquotereq_;
#else
  return getquotereq_ != NULL ? *getquotereq_ : *default_instance_->getquotereq_;
#endif
}
inline ::aesm::message::Request_GetQuoteRequest* Request::mutable_getquotereq() {
  set_has_getquotereq();
  if (getquotereq_ == NULL) {
    getquotereq_ = new ::aesm::message::Request_GetQuoteRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getQuoteReq)
  return getquotereq_;
}
inline ::aesm::message::Request_GetQuoteRequest* Request::release_getquotereq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getQuoteReq)
  clear_has_getquotereq();
  ::aesm::message::Request_GetQuoteRequest* temp = getquotereq_;
  getquotereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getquotereq(::aesm::message::Request_GetQuoteRequest* getquotereq) {
  delete getquotereq_;
  getquotereq_ = getquotereq;
  if (getquotereq) {
    set_has_getquotereq();
  } else {
    clear_has_getquotereq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getQuoteReq)
}

// optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;
inline bool Request::has_getlictokenreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_getlictokenreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_getlictokenreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_getlictokenreq() {
  if (getlictokenreq_ != NULL) getlictokenreq_->::aesm::message::Request_GetLaunchTokenRequest::Clear();
  clear_has_getlictokenreq();
}
inline const ::aesm::message::Request_GetLaunchTokenRequest& Request::getlictokenreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getLicTokenReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getlictokenreq_ != NULL ? *getlictokenreq_ : *default_instance().getlictokenreq_;
#else
  return getlictokenreq_ != NULL ? *getlictokenreq_ : *default_instance_->getlictokenreq_;
#endif
}
inline ::aesm::message::Request_GetLaunchTokenRequest* Request::mutable_getlictokenreq() {
  set_has_getlictokenreq();
  if (getlictokenreq_ == NULL) {
    getlictokenreq_ = new ::aesm::message::Request_GetLaunchTokenRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getLicTokenReq)
  return getlictokenreq_;
}
inline ::aesm::message::Request_GetLaunchTokenRequest* Request::release_getlictokenreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getLicTokenReq)
  clear_has_getlictokenreq();
  ::aesm::message::Request_GetLaunchTokenRequest* temp = getlictokenreq_;
  getlictokenreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getlictokenreq(::aesm::message::Request_GetLaunchTokenRequest* getlictokenreq) {
  delete getlictokenreq_;
  getlictokenreq_ = getlictokenreq;
  if (getlictokenreq) {
    set_has_getlictokenreq();
  } else {
    clear_has_getlictokenreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getLicTokenReq)
}

// optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;
inline bool Request::has_reporterrreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_reporterrreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_reporterrreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_reporterrreq() {
  if (reporterrreq_ != NULL) reporterrreq_->::aesm::message::Request_ReportAttestationErrorRequest::Clear();
  clear_has_reporterrreq();
}
inline const ::aesm::message::Request_ReportAttestationErrorRequest& Request::reporterrreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.reportErrReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reporterrreq_ != NULL ? *reporterrreq_ : *default_instance().reporterrreq_;
#else
  return reporterrreq_ != NULL ? *reporterrreq_ : *default_instance_->reporterrreq_;
#endif
}
inline ::aesm::message::Request_ReportAttestationErrorRequest* Request::mutable_reporterrreq() {
  set_has_reporterrreq();
  if (reporterrreq_ == NULL) {
    reporterrreq_ = new ::aesm::message::Request_ReportAttestationErrorRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.reportErrReq)
  return reporterrreq_;
}
inline ::aesm::message::Request_ReportAttestationErrorRequest* Request::release_reporterrreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.reportErrReq)
  clear_has_reporterrreq();
  ::aesm::message::Request_ReportAttestationErrorRequest* temp = reporterrreq_;
  reporterrreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_reporterrreq(::aesm::message::Request_ReportAttestationErrorRequest* reporterrreq) {
  delete reporterrreq_;
  reporterrreq_ = reporterrreq;
  if (reporterrreq) {
    set_has_reporterrreq();
  } else {
    clear_has_reporterrreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.reportErrReq)
}

// optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;
inline bool Request::has_getwhitelistsizereq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_getwhitelistsizereq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_getwhitelistsizereq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_getwhitelistsizereq() {
  if (getwhitelistsizereq_ != NULL) getwhitelistsizereq_->::aesm::message::Request_GetWhiteListSizeRequest::Clear();
  clear_has_getwhitelistsizereq();
}
inline const ::aesm::message::Request_GetWhiteListSizeRequest& Request::getwhitelistsizereq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getWhiteListSizeReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getwhitelistsizereq_ != NULL ? *getwhitelistsizereq_ : *default_instance().getwhitelistsizereq_;
#else
  return getwhitelistsizereq_ != NULL ? *getwhitelistsizereq_ : *default_instance_->getwhitelistsizereq_;
#endif
}
inline ::aesm::message::Request_GetWhiteListSizeRequest* Request::mutable_getwhitelistsizereq() {
  set_has_getwhitelistsizereq();
  if (getwhitelistsizereq_ == NULL) {
    getwhitelistsizereq_ = new ::aesm::message::Request_GetWhiteListSizeRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getWhiteListSizeReq)
  return getwhitelistsizereq_;
}
inline ::aesm::message::Request_GetWhiteListSizeRequest* Request::release_getwhitelistsizereq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getWhiteListSizeReq)
  clear_has_getwhitelistsizereq();
  ::aesm::message::Request_GetWhiteListSizeRequest* temp = getwhitelistsizereq_;
  getwhitelistsizereq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getwhitelistsizereq(::aesm::message::Request_GetWhiteListSizeRequest* getwhitelistsizereq) {
  delete getwhitelistsizereq_;
  getwhitelistsizereq_ = getwhitelistsizereq;
  if (getwhitelistsizereq) {
    set_has_getwhitelistsizereq();
  } else {
    clear_has_getwhitelistsizereq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getWhiteListSizeReq)
}

// optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;
inline bool Request::has_getwhitelistreq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_getwhitelistreq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_getwhitelistreq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_getwhitelistreq() {
  if (getwhitelistreq_ != NULL) getwhitelistreq_->::aesm::message::Request_GetWhiteListRequest::Clear();
  clear_has_getwhitelistreq();
}
inline const ::aesm::message::Request_GetWhiteListRequest& Request::getwhitelistreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getWhiteListReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getwhitelistreq_ != NULL ? *getwhitelistreq_ : *default_instance().getwhitelistreq_;
#else
  return getwhitelistreq_ != NULL ? *getwhitelistreq_ : *default_instance_->getwhitelistreq_;
#endif
}
inline ::aesm::message::Request_GetWhiteListRequest* Request::mutable_getwhitelistreq() {
  set_has_getwhitelistreq();
  if (getwhitelistreq_ == NULL) {
    getwhitelistreq_ = new ::aesm::message::Request_GetWhiteListRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getWhiteListReq)
  return getwhitelistreq_;
}
inline ::aesm::message::Request_GetWhiteListRequest* Request::release_getwhitelistreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getWhiteListReq)
  clear_has_getwhitelistreq();
  ::aesm::message::Request_GetWhiteListRequest* temp = getwhitelistreq_;
  getwhitelistreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getwhitelistreq(::aesm::message::Request_GetWhiteListRequest* getwhitelistreq) {
  delete getwhitelistreq_;
  getwhitelistreq_ = getwhitelistreq;
  if (getwhitelistreq) {
    set_has_getwhitelistreq();
  } else {
    clear_has_getwhitelistreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getWhiteListReq)
}

// optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;
inline bool Request::has_sgxgetextendedepidgroupidreq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_sgxgetextendedepidgroupidreq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_sgxgetextendedepidgroupidreq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_sgxgetextendedepidgroupidreq() {
  if (sgxgetextendedepidgroupidreq_ != NULL) sgxgetextendedepidgroupidreq_->::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest::Clear();
  clear_has_sgxgetextendedepidgroupidreq();
}
inline const ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest& Request::sgxgetextendedepidgroupidreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.sgxGetExtendedEpidGroupIdReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxgetextendedepidgroupidreq_ != NULL ? *sgxgetextendedepidgroupidreq_ : *default_instance().sgxgetextendedepidgroupidreq_;
#else
  return sgxgetextendedepidgroupidreq_ != NULL ? *sgxgetextendedepidgroupidreq_ : *default_instance_->sgxgetextendedepidgroupidreq_;
#endif
}
inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* Request::mutable_sgxgetextendedepidgroupidreq() {
  set_has_sgxgetextendedepidgroupidreq();
  if (sgxgetextendedepidgroupidreq_ == NULL) {
    sgxgetextendedepidgroupidreq_ = new ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.sgxGetExtendedEpidGroupIdReq)
  return sgxgetextendedepidgroupidreq_;
}
inline ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* Request::release_sgxgetextendedepidgroupidreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.sgxGetExtendedEpidGroupIdReq)
  clear_has_sgxgetextendedepidgroupidreq();
  ::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* temp = sgxgetextendedepidgroupidreq_;
  sgxgetextendedepidgroupidreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_sgxgetextendedepidgroupidreq(::aesm::message::Request_SGXGetExtendedEpidGroupIdRequest* sgxgetextendedepidgroupidreq) {
  delete sgxgetextendedepidgroupidreq_;
  sgxgetextendedepidgroupidreq_ = sgxgetextendedepidgroupidreq;
  if (sgxgetextendedepidgroupidreq) {
    set_has_sgxgetextendedepidgroupidreq();
  } else {
    clear_has_sgxgetextendedepidgroupidreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.sgxGetExtendedEpidGroupIdReq)
}

// optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;
inline bool Request::has_sgxswitchextendedepidgroupreq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_sgxswitchextendedepidgroupreq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_sgxswitchextendedepidgroupreq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_sgxswitchextendedepidgroupreq() {
  if (sgxswitchextendedepidgroupreq_ != NULL) sgxswitchextendedepidgroupreq_->::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest::Clear();
  clear_has_sgxswitchextendedepidgroupreq();
}
inline const ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest& Request::sgxswitchextendedepidgroupreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.sgxSwitchExtendedEpidGroupReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxswitchextendedepidgroupreq_ != NULL ? *sgxswitchextendedepidgroupreq_ : *default_instance().sgxswitchextendedepidgroupreq_;
#else
  return sgxswitchextendedepidgroupreq_ != NULL ? *sgxswitchextendedepidgroupreq_ : *default_instance_->sgxswitchextendedepidgroupreq_;
#endif
}
inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* Request::mutable_sgxswitchextendedepidgroupreq() {
  set_has_sgxswitchextendedepidgroupreq();
  if (sgxswitchextendedepidgroupreq_ == NULL) {
    sgxswitchextendedepidgroupreq_ = new ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.sgxSwitchExtendedEpidGroupReq)
  return sgxswitchextendedepidgroupreq_;
}
inline ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* Request::release_sgxswitchextendedepidgroupreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.sgxSwitchExtendedEpidGroupReq)
  clear_has_sgxswitchextendedepidgroupreq();
  ::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* temp = sgxswitchextendedepidgroupreq_;
  sgxswitchextendedepidgroupreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_sgxswitchextendedepidgroupreq(::aesm::message::Request_SGXSwitchExtendedEpidGroupRequest* sgxswitchextendedepidgroupreq) {
  delete sgxswitchextendedepidgroupreq_;
  sgxswitchextendedepidgroupreq_ = sgxswitchextendedepidgroupreq;
  if (sgxswitchextendedepidgroupreq) {
    set_has_sgxswitchextendedepidgroupreq();
  } else {
    clear_has_sgxswitchextendedepidgroupreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.sgxSwitchExtendedEpidGroupReq)
}

// optional .aesm.message.Request.SGXRegisterRequest sgxRegisterReq = 14;
inline bool Request::has_sgxregisterreq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_sgxregisterreq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_sgxregisterreq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_sgxregisterreq() {
  if (sgxregisterreq_ != NULL) sgxregisterreq_->::aesm::message::Request_SGXRegisterRequest::Clear();
  clear_has_sgxregisterreq();
}
inline const ::aesm::message::Request_SGXRegisterRequest& Request::sgxregisterreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.sgxRegisterReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxregisterreq_ != NULL ? *sgxregisterreq_ : *default_instance().sgxregisterreq_;
#else
  return sgxregisterreq_ != NULL ? *sgxregisterreq_ : *default_instance_->sgxregisterreq_;
#endif
}
inline ::aesm::message::Request_SGXRegisterRequest* Request::mutable_sgxregisterreq() {
  set_has_sgxregisterreq();
  if (sgxregisterreq_ == NULL) {
    sgxregisterreq_ = new ::aesm::message::Request_SGXRegisterRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.sgxRegisterReq)
  return sgxregisterreq_;
}
inline ::aesm::message::Request_SGXRegisterRequest* Request::release_sgxregisterreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.sgxRegisterReq)
  clear_has_sgxregisterreq();
  ::aesm::message::Request_SGXRegisterRequest* temp = sgxregisterreq_;
  sgxregisterreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_sgxregisterreq(::aesm::message::Request_SGXRegisterRequest* sgxregisterreq) {
  delete sgxregisterreq_;
  sgxregisterreq_ = sgxregisterreq;
  if (sgxregisterreq) {
    set_has_sgxregisterreq();
  } else {
    clear_has_sgxregisterreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.sgxRegisterReq)
}

// optional .aesm.message.Request.InitQuoteExRequest initQuoteExReq = 15;
inline bool Request::has_initquoteexreq() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_initquoteexreq() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_initquoteexreq() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_initquoteexreq() {
  if (initquoteexreq_ != NULL) initquoteexreq_->::aesm::message::Request_InitQuoteExRequest::Clear();
  clear_has_initquoteexreq();
}
inline const ::aesm::message::Request_InitQuoteExRequest& Request::initquoteexreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.initQuoteExReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initquoteexreq_ != NULL ? *initquoteexreq_ : *default_instance().initquoteexreq_;
#else
  return initquoteexreq_ != NULL ? *initquoteexreq_ : *default_instance_->initquoteexreq_;
#endif
}
inline ::aesm::message::Request_InitQuoteExRequest* Request::mutable_initquoteexreq() {
  set_has_initquoteexreq();
  if (initquoteexreq_ == NULL) {
    initquoteexreq_ = new ::aesm::message::Request_InitQuoteExRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.initQuoteExReq)
  return initquoteexreq_;
}
inline ::aesm::message::Request_InitQuoteExRequest* Request::release_initquoteexreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.initQuoteExReq)
  clear_has_initquoteexreq();
  ::aesm::message::Request_InitQuoteExRequest* temp = initquoteexreq_;
  initquoteexreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_initquoteexreq(::aesm::message::Request_InitQuoteExRequest* initquoteexreq) {
  delete initquoteexreq_;
  initquoteexreq_ = initquoteexreq;
  if (initquoteexreq) {
    set_has_initquoteexreq();
  } else {
    clear_has_initquoteexreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.initQuoteExReq)
}

// optional .aesm.message.Request.GetQuoteSizeExRequest getQuoteSizeExReq = 16;
inline bool Request::has_getquotesizeexreq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_getquotesizeexreq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_getquotesizeexreq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_getquotesizeexreq() {
  if (getquotesizeexreq_ != NULL) getquotesizeexreq_->::aesm::message::Request_GetQuoteSizeExRequest::Clear();
  clear_has_getquotesizeexreq();
}
inline const ::aesm::message::Request_GetQuoteSizeExRequest& Request::getquotesizeexreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getQuoteSizeExReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquotesizeexreq_ != NULL ? *getquotesizeexreq_ : *default_instance().getquotesizeexreq_;
#else
  return getquotesizeexreq_ != NULL ? *getquotesizeexreq_ : *default_instance_->getquotesizeexreq_;
#endif
}
inline ::aesm::message::Request_GetQuoteSizeExRequest* Request::mutable_getquotesizeexreq() {
  set_has_getquotesizeexreq();
  if (getquotesizeexreq_ == NULL) {
    getquotesizeexreq_ = new ::aesm::message::Request_GetQuoteSizeExRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getQuoteSizeExReq)
  return getquotesizeexreq_;
}
inline ::aesm::message::Request_GetQuoteSizeExRequest* Request::release_getquotesizeexreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getQuoteSizeExReq)
  clear_has_getquotesizeexreq();
  ::aesm::message::Request_GetQuoteSizeExRequest* temp = getquotesizeexreq_;
  getquotesizeexreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getquotesizeexreq(::aesm::message::Request_GetQuoteSizeExRequest* getquotesizeexreq) {
  delete getquotesizeexreq_;
  getquotesizeexreq_ = getquotesizeexreq;
  if (getquotesizeexreq) {
    set_has_getquotesizeexreq();
  } else {
    clear_has_getquotesizeexreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getQuoteSizeExReq)
}

// optional .aesm.message.Request.GetQuoteExRequest getQuoteExReq = 17;
inline bool Request::has_getquoteexreq() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_getquoteexreq() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_getquoteexreq() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_getquoteexreq() {
  if (getquoteexreq_ != NULL) getquoteexreq_->::aesm::message::Request_GetQuoteExRequest::Clear();
  clear_has_getquoteexreq();
}
inline const ::aesm::message::Request_GetQuoteExRequest& Request::getquoteexreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getQuoteExReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquoteexreq_ != NULL ? *getquoteexreq_ : *default_instance().getquoteexreq_;
#else
  return getquoteexreq_ != NULL ? *getquoteexreq_ : *default_instance_->getquoteexreq_;
#endif
}
inline ::aesm::message::Request_GetQuoteExRequest* Request::mutable_getquoteexreq() {
  set_has_getquoteexreq();
  if (getquoteexreq_ == NULL) {
    getquoteexreq_ = new ::aesm::message::Request_GetQuoteExRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getQuoteExReq)
  return getquoteexreq_;
}
inline ::aesm::message::Request_GetQuoteExRequest* Request::release_getquoteexreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getQuoteExReq)
  clear_has_getquoteexreq();
  ::aesm::message::Request_GetQuoteExRequest* temp = getquoteexreq_;
  getquoteexreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getquoteexreq(::aesm::message::Request_GetQuoteExRequest* getquoteexreq) {
  delete getquoteexreq_;
  getquoteexreq_ = getquoteexreq;
  if (getquoteexreq) {
    set_has_getquoteexreq();
  } else {
    clear_has_getquoteexreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getQuoteExReq)
}

// optional .aesm.message.Request.CheckUpdateStatusRequest checkUpdateStatusReq = 18;
inline bool Request::has_checkupdatestatusreq() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_checkupdatestatusreq() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_checkupdatestatusreq() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_checkupdatestatusreq() {
  if (checkupdatestatusreq_ != NULL) checkupdatestatusreq_->::aesm::message::Request_CheckUpdateStatusRequest::Clear();
  clear_has_checkupdatestatusreq();
}
inline const ::aesm::message::Request_CheckUpdateStatusRequest& Request::checkupdatestatusreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.checkUpdateStatusReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checkupdatestatusreq_ != NULL ? *checkupdatestatusreq_ : *default_instance().checkupdatestatusreq_;
#else
  return checkupdatestatusreq_ != NULL ? *checkupdatestatusreq_ : *default_instance_->checkupdatestatusreq_;
#endif
}
inline ::aesm::message::Request_CheckUpdateStatusRequest* Request::mutable_checkupdatestatusreq() {
  set_has_checkupdatestatusreq();
  if (checkupdatestatusreq_ == NULL) {
    checkupdatestatusreq_ = new ::aesm::message::Request_CheckUpdateStatusRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.checkUpdateStatusReq)
  return checkupdatestatusreq_;
}
inline ::aesm::message::Request_CheckUpdateStatusRequest* Request::release_checkupdatestatusreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.checkUpdateStatusReq)
  clear_has_checkupdatestatusreq();
  ::aesm::message::Request_CheckUpdateStatusRequest* temp = checkupdatestatusreq_;
  checkupdatestatusreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_checkupdatestatusreq(::aesm::message::Request_CheckUpdateStatusRequest* checkupdatestatusreq) {
  delete checkupdatestatusreq_;
  checkupdatestatusreq_ = checkupdatestatusreq;
  if (checkupdatestatusreq) {
    set_has_checkupdatestatusreq();
  } else {
    clear_has_checkupdatestatusreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.checkUpdateStatusReq)
}

// optional .aesm.message.Request.SelectAttKeyIDRequest selectAttKeyIDReq = 19;
inline bool Request::has_selectattkeyidreq() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_selectattkeyidreq() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_selectattkeyidreq() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_selectattkeyidreq() {
  if (selectattkeyidreq_ != NULL) selectattkeyidreq_->::aesm::message::Request_SelectAttKeyIDRequest::Clear();
  clear_has_selectattkeyidreq();
}
inline const ::aesm::message::Request_SelectAttKeyIDRequest& Request::selectattkeyidreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.selectAttKeyIDReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selectattkeyidreq_ != NULL ? *selectattkeyidreq_ : *default_instance().selectattkeyidreq_;
#else
  return selectattkeyidreq_ != NULL ? *selectattkeyidreq_ : *default_instance_->selectattkeyidreq_;
#endif
}
inline ::aesm::message::Request_SelectAttKeyIDRequest* Request::mutable_selectattkeyidreq() {
  set_has_selectattkeyidreq();
  if (selectattkeyidreq_ == NULL) {
    selectattkeyidreq_ = new ::aesm::message::Request_SelectAttKeyIDRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.selectAttKeyIDReq)
  return selectattkeyidreq_;
}
inline ::aesm::message::Request_SelectAttKeyIDRequest* Request::release_selectattkeyidreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.selectAttKeyIDReq)
  clear_has_selectattkeyidreq();
  ::aesm::message::Request_SelectAttKeyIDRequest* temp = selectattkeyidreq_;
  selectattkeyidreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_selectattkeyidreq(::aesm::message::Request_SelectAttKeyIDRequest* selectattkeyidreq) {
  delete selectattkeyidreq_;
  selectattkeyidreq_ = selectattkeyidreq;
  if (selectattkeyidreq) {
    set_has_selectattkeyidreq();
  } else {
    clear_has_selectattkeyidreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.selectAttKeyIDReq)
}

// optional .aesm.message.Request.GetSupportedAttKeyIDNumRequest getSupportedAttKeyIDNumReq = 21;
inline bool Request::has_getsupportedattkeyidnumreq() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_getsupportedattkeyidnumreq() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_getsupportedattkeyidnumreq() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_getsupportedattkeyidnumreq() {
  if (getsupportedattkeyidnumreq_ != NULL) getsupportedattkeyidnumreq_->::aesm::message::Request_GetSupportedAttKeyIDNumRequest::Clear();
  clear_has_getsupportedattkeyidnumreq();
}
inline const ::aesm::message::Request_GetSupportedAttKeyIDNumRequest& Request::getsupportedattkeyidnumreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getSupportedAttKeyIDNumReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getsupportedattkeyidnumreq_ != NULL ? *getsupportedattkeyidnumreq_ : *default_instance().getsupportedattkeyidnumreq_;
#else
  return getsupportedattkeyidnumreq_ != NULL ? *getsupportedattkeyidnumreq_ : *default_instance_->getsupportedattkeyidnumreq_;
#endif
}
inline ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* Request::mutable_getsupportedattkeyidnumreq() {
  set_has_getsupportedattkeyidnumreq();
  if (getsupportedattkeyidnumreq_ == NULL) {
    getsupportedattkeyidnumreq_ = new ::aesm::message::Request_GetSupportedAttKeyIDNumRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getSupportedAttKeyIDNumReq)
  return getsupportedattkeyidnumreq_;
}
inline ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* Request::release_getsupportedattkeyidnumreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getSupportedAttKeyIDNumReq)
  clear_has_getsupportedattkeyidnumreq();
  ::aesm::message::Request_GetSupportedAttKeyIDNumRequest* temp = getsupportedattkeyidnumreq_;
  getsupportedattkeyidnumreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getsupportedattkeyidnumreq(::aesm::message::Request_GetSupportedAttKeyIDNumRequest* getsupportedattkeyidnumreq) {
  delete getsupportedattkeyidnumreq_;
  getsupportedattkeyidnumreq_ = getsupportedattkeyidnumreq;
  if (getsupportedattkeyidnumreq) {
    set_has_getsupportedattkeyidnumreq();
  } else {
    clear_has_getsupportedattkeyidnumreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getSupportedAttKeyIDNumReq)
}

// optional .aesm.message.Request.GetSupportedAttKeyIDsRequest getSupportedAttKeyIDsReq = 22;
inline bool Request::has_getsupportedattkeyidsreq() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Request::set_has_getsupportedattkeyidsreq() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Request::clear_has_getsupportedattkeyidsreq() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Request::clear_getsupportedattkeyidsreq() {
  if (getsupportedattkeyidsreq_ != NULL) getsupportedattkeyidsreq_->::aesm::message::Request_GetSupportedAttKeyIDsRequest::Clear();
  clear_has_getsupportedattkeyidsreq();
}
inline const ::aesm::message::Request_GetSupportedAttKeyIDsRequest& Request::getsupportedattkeyidsreq() const {
  // @@protoc_insertion_point(field_get:aesm.message.Request.getSupportedAttKeyIDsReq)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getsupportedattkeyidsreq_ != NULL ? *getsupportedattkeyidsreq_ : *default_instance().getsupportedattkeyidsreq_;
#else
  return getsupportedattkeyidsreq_ != NULL ? *getsupportedattkeyidsreq_ : *default_instance_->getsupportedattkeyidsreq_;
#endif
}
inline ::aesm::message::Request_GetSupportedAttKeyIDsRequest* Request::mutable_getsupportedattkeyidsreq() {
  set_has_getsupportedattkeyidsreq();
  if (getsupportedattkeyidsreq_ == NULL) {
    getsupportedattkeyidsreq_ = new ::aesm::message::Request_GetSupportedAttKeyIDsRequest;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Request.getSupportedAttKeyIDsReq)
  return getsupportedattkeyidsreq_;
}
inline ::aesm::message::Request_GetSupportedAttKeyIDsRequest* Request::release_getsupportedattkeyidsreq() {
  // @@protoc_insertion_point(field_release:aesm.message.Request.getSupportedAttKeyIDsReq)
  clear_has_getsupportedattkeyidsreq();
  ::aesm::message::Request_GetSupportedAttKeyIDsRequest* temp = getsupportedattkeyidsreq_;
  getsupportedattkeyidsreq_ = NULL;
  return temp;
}
inline void Request::set_allocated_getsupportedattkeyidsreq(::aesm::message::Request_GetSupportedAttKeyIDsRequest* getsupportedattkeyidsreq) {
  delete getsupportedattkeyidsreq_;
  getsupportedattkeyidsreq_ = getsupportedattkeyidsreq;
  if (getsupportedattkeyidsreq) {
    set_has_getsupportedattkeyidsreq();
  } else {
    clear_has_getsupportedattkeyidsreq();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Request.getSupportedAttKeyIDsReq)
}

// -------------------------------------------------------------------

// Response_InitQuoteResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_InitQuoteResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_InitQuoteResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_InitQuoteResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_InitQuoteResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_InitQuoteResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteResponse.errorCode)
  return errorcode_;
}
inline void Response_InitQuoteResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteResponse.errorCode)
}

// optional bytes targetInfo = 2;
inline bool Response_InitQuoteResponse::has_targetinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_InitQuoteResponse::set_has_targetinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_InitQuoteResponse::clear_has_targetinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_InitQuoteResponse::clear_targetinfo() {
  targetinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_targetinfo();
}
inline const ::std::string& Response_InitQuoteResponse::targetinfo() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteResponse.targetInfo)
  return targetinfo_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteResponse::set_targetinfo(const ::std::string& value) {
  set_has_targetinfo();
  targetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteResponse.targetInfo)
}
inline void Response_InitQuoteResponse::set_targetinfo(const char* value) {
  set_has_targetinfo();
  targetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.InitQuoteResponse.targetInfo)
}
inline void Response_InitQuoteResponse::set_targetinfo(const void* value, size_t size) {
  set_has_targetinfo();
  targetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.InitQuoteResponse.targetInfo)
}
inline ::std::string* Response_InitQuoteResponse::mutable_targetinfo() {
  set_has_targetinfo();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.InitQuoteResponse.targetInfo)
  return targetinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_InitQuoteResponse::release_targetinfo() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.InitQuoteResponse.targetInfo)
  clear_has_targetinfo();
  return targetinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteResponse::set_allocated_targetinfo(::std::string* targetinfo) {
  if (targetinfo != NULL) {
    set_has_targetinfo();
  } else {
    clear_has_targetinfo();
  }
  targetinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetinfo);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.InitQuoteResponse.targetInfo)
}

// optional bytes gid = 3;
inline bool Response_InitQuoteResponse::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_InitQuoteResponse::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_InitQuoteResponse::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_InitQuoteResponse::clear_gid() {
  gid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gid();
}
inline const ::std::string& Response_InitQuoteResponse::gid() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteResponse.gid)
  return gid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteResponse::set_gid(const ::std::string& value) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteResponse.gid)
}
inline void Response_InitQuoteResponse::set_gid(const char* value) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.InitQuoteResponse.gid)
}
inline void Response_InitQuoteResponse::set_gid(const void* value, size_t size) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.InitQuoteResponse.gid)
}
inline ::std::string* Response_InitQuoteResponse::mutable_gid() {
  set_has_gid();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.InitQuoteResponse.gid)
  return gid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_InitQuoteResponse::release_gid() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.InitQuoteResponse.gid)
  clear_has_gid();
  return gid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteResponse::set_allocated_gid(::std::string* gid) {
  if (gid != NULL) {
    set_has_gid();
  } else {
    clear_has_gid();
  }
  gid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gid);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.InitQuoteResponse.gid)
}

// -------------------------------------------------------------------

// Response_GetQuoteResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetQuoteResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetQuoteResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetQuoteResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetQuoteResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetQuoteResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteResponse.errorCode)
  return errorcode_;
}
inline void Response_GetQuoteResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteResponse.errorCode)
}

// optional bytes quote = 2;
inline bool Response_GetQuoteResponse::has_quote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetQuoteResponse::set_has_quote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetQuoteResponse::clear_has_quote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetQuoteResponse::clear_quote() {
  quote_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_quote();
}
inline const ::std::string& Response_GetQuoteResponse::quote() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteResponse.quote)
  return quote_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteResponse::set_quote(const ::std::string& value) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteResponse.quote)
}
inline void Response_GetQuoteResponse::set_quote(const char* value) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetQuoteResponse.quote)
}
inline void Response_GetQuoteResponse::set_quote(const void* value, size_t size) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetQuoteResponse.quote)
}
inline ::std::string* Response_GetQuoteResponse::mutable_quote() {
  set_has_quote();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetQuoteResponse.quote)
  return quote_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetQuoteResponse::release_quote() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetQuoteResponse.quote)
  clear_has_quote();
  return quote_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteResponse::set_allocated_quote(::std::string* quote) {
  if (quote != NULL) {
    set_has_quote();
  } else {
    clear_has_quote();
  }
  quote_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quote);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetQuoteResponse.quote)
}

// optional bytes qe_report = 3;
inline bool Response_GetQuoteResponse::has_qe_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetQuoteResponse::set_has_qe_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetQuoteResponse::clear_has_qe_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetQuoteResponse::clear_qe_report() {
  qe_report_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qe_report();
}
inline const ::std::string& Response_GetQuoteResponse::qe_report() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteResponse.qe_report)
  return qe_report_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteResponse::set_qe_report(const ::std::string& value) {
  set_has_qe_report();
  qe_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteResponse.qe_report)
}
inline void Response_GetQuoteResponse::set_qe_report(const char* value) {
  set_has_qe_report();
  qe_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetQuoteResponse.qe_report)
}
inline void Response_GetQuoteResponse::set_qe_report(const void* value, size_t size) {
  set_has_qe_report();
  qe_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetQuoteResponse.qe_report)
}
inline ::std::string* Response_GetQuoteResponse::mutable_qe_report() {
  set_has_qe_report();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetQuoteResponse.qe_report)
  return qe_report_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetQuoteResponse::release_qe_report() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetQuoteResponse.qe_report)
  clear_has_qe_report();
  return qe_report_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteResponse::set_allocated_qe_report(::std::string* qe_report) {
  if (qe_report != NULL) {
    set_has_qe_report();
  } else {
    clear_has_qe_report();
  }
  qe_report_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qe_report);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetQuoteResponse.qe_report)
}

// -------------------------------------------------------------------

// Response_GetLaunchTokenResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetLaunchTokenResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetLaunchTokenResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetLaunchTokenResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetLaunchTokenResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetLaunchTokenResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetLaunchTokenResponse.errorCode)
  return errorcode_;
}
inline void Response_GetLaunchTokenResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetLaunchTokenResponse.errorCode)
}

// optional bytes token = 2;
inline bool Response_GetLaunchTokenResponse::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetLaunchTokenResponse::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetLaunchTokenResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetLaunchTokenResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& Response_GetLaunchTokenResponse::token() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetLaunchTokenResponse.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetLaunchTokenResponse::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetLaunchTokenResponse.token)
}
inline void Response_GetLaunchTokenResponse::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetLaunchTokenResponse.token)
}
inline void Response_GetLaunchTokenResponse::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetLaunchTokenResponse.token)
}
inline ::std::string* Response_GetLaunchTokenResponse::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetLaunchTokenResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetLaunchTokenResponse::release_token() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetLaunchTokenResponse.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetLaunchTokenResponse::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetLaunchTokenResponse.token)
}

// -------------------------------------------------------------------

// Response_ReportAttestationErrorResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_ReportAttestationErrorResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReportAttestationErrorResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReportAttestationErrorResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReportAttestationErrorResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_ReportAttestationErrorResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.ReportAttestationErrorResponse.errorCode)
  return errorcode_;
}
inline void Response_ReportAttestationErrorResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.ReportAttestationErrorResponse.errorCode)
}

// optional bytes platform_update_info = 2;
inline bool Response_ReportAttestationErrorResponse::has_platform_update_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReportAttestationErrorResponse::set_has_platform_update_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReportAttestationErrorResponse::clear_has_platform_update_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReportAttestationErrorResponse::clear_platform_update_info() {
  platform_update_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform_update_info();
}
inline const ::std::string& Response_ReportAttestationErrorResponse::platform_update_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
  return platform_update_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const ::std::string& value) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const char* value) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
}
inline void Response_ReportAttestationErrorResponse::set_platform_update_info(const void* value, size_t size) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
}
inline ::std::string* Response_ReportAttestationErrorResponse::mutable_platform_update_info() {
  set_has_platform_update_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
  return platform_update_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_ReportAttestationErrorResponse::release_platform_update_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
  clear_has_platform_update_info();
  return platform_update_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_ReportAttestationErrorResponse::set_allocated_platform_update_info(::std::string* platform_update_info) {
  if (platform_update_info != NULL) {
    set_has_platform_update_info();
  } else {
    clear_has_platform_update_info();
  }
  platform_update_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform_update_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.ReportAttestationErrorResponse.platform_update_info)
}

// -------------------------------------------------------------------

// Response_CheckUpdateStatusResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_CheckUpdateStatusResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_CheckUpdateStatusResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_CheckUpdateStatusResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_CheckUpdateStatusResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_CheckUpdateStatusResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.CheckUpdateStatusResponse.errorCode)
  return errorcode_;
}
inline void Response_CheckUpdateStatusResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.CheckUpdateStatusResponse.errorCode)
}

// optional bytes platform_update_info = 2;
inline bool Response_CheckUpdateStatusResponse::has_platform_update_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_CheckUpdateStatusResponse::set_has_platform_update_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_CheckUpdateStatusResponse::clear_has_platform_update_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_CheckUpdateStatusResponse::clear_platform_update_info() {
  platform_update_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform_update_info();
}
inline const ::std::string& Response_CheckUpdateStatusResponse::platform_update_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
  return platform_update_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_CheckUpdateStatusResponse::set_platform_update_info(const ::std::string& value) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
}
inline void Response_CheckUpdateStatusResponse::set_platform_update_info(const char* value) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
}
inline void Response_CheckUpdateStatusResponse::set_platform_update_info(const void* value, size_t size) {
  set_has_platform_update_info();
  platform_update_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
}
inline ::std::string* Response_CheckUpdateStatusResponse::mutable_platform_update_info() {
  set_has_platform_update_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
  return platform_update_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_CheckUpdateStatusResponse::release_platform_update_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
  clear_has_platform_update_info();
  return platform_update_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_CheckUpdateStatusResponse::set_allocated_platform_update_info(::std::string* platform_update_info) {
  if (platform_update_info != NULL) {
    set_has_platform_update_info();
  } else {
    clear_has_platform_update_info();
  }
  platform_update_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform_update_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.CheckUpdateStatusResponse.platform_update_info)
}

// optional uint32 status = 3;
inline bool Response_CheckUpdateStatusResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_CheckUpdateStatusResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_CheckUpdateStatusResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_CheckUpdateStatusResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 Response_CheckUpdateStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.CheckUpdateStatusResponse.status)
  return status_;
}
inline void Response_CheckUpdateStatusResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.CheckUpdateStatusResponse.status)
}

// -------------------------------------------------------------------

// Response_GetWhiteListSizeResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetWhiteListSizeResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetWhiteListSizeResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetWhiteListSizeResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetWhiteListSizeResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetWhiteListSizeResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetWhiteListSizeResponse.errorCode)
  return errorcode_;
}
inline void Response_GetWhiteListSizeResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetWhiteListSizeResponse.errorCode)
}

// optional uint32 white_list_size = 2;
inline bool Response_GetWhiteListSizeResponse::has_white_list_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetWhiteListSizeResponse::set_has_white_list_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetWhiteListSizeResponse::clear_has_white_list_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetWhiteListSizeResponse::clear_white_list_size() {
  white_list_size_ = 0u;
  clear_has_white_list_size();
}
inline ::google::protobuf::uint32 Response_GetWhiteListSizeResponse::white_list_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetWhiteListSizeResponse.white_list_size)
  return white_list_size_;
}
inline void Response_GetWhiteListSizeResponse::set_white_list_size(::google::protobuf::uint32 value) {
  set_has_white_list_size();
  white_list_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetWhiteListSizeResponse.white_list_size)
}

// -------------------------------------------------------------------

// Response_GetWhiteListResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetWhiteListResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetWhiteListResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetWhiteListResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetWhiteListResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetWhiteListResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetWhiteListResponse.errorCode)
  return errorcode_;
}
inline void Response_GetWhiteListResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetWhiteListResponse.errorCode)
}

// optional bytes white_list = 2;
inline bool Response_GetWhiteListResponse::has_white_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetWhiteListResponse::set_has_white_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetWhiteListResponse::clear_has_white_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetWhiteListResponse::clear_white_list() {
  white_list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_white_list();
}
inline const ::std::string& Response_GetWhiteListResponse::white_list() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetWhiteListResponse.white_list)
  return white_list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetWhiteListResponse::set_white_list(const ::std::string& value) {
  set_has_white_list();
  white_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetWhiteListResponse.white_list)
}
inline void Response_GetWhiteListResponse::set_white_list(const char* value) {
  set_has_white_list();
  white_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetWhiteListResponse.white_list)
}
inline void Response_GetWhiteListResponse::set_white_list(const void* value, size_t size) {
  set_has_white_list();
  white_list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetWhiteListResponse.white_list)
}
inline ::std::string* Response_GetWhiteListResponse::mutable_white_list() {
  set_has_white_list();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetWhiteListResponse.white_list)
  return white_list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetWhiteListResponse::release_white_list() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetWhiteListResponse.white_list)
  clear_has_white_list();
  return white_list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetWhiteListResponse::set_allocated_white_list(::std::string* white_list) {
  if (white_list != NULL) {
    set_has_white_list();
  } else {
    clear_has_white_list();
  }
  white_list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), white_list);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetWhiteListResponse.white_list)
}

// -------------------------------------------------------------------

// Response_SGXGetExtendedEpidGroupIdResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SGXGetExtendedEpidGroupIdResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SGXGetExtendedEpidGroupIdResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse.errorCode)
  return errorcode_;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse.errorCode)
}

// optional uint32 x_group_id = 2;
inline bool Response_SGXGetExtendedEpidGroupIdResponse::has_x_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_has_x_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_has_x_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::clear_x_group_id() {
  x_group_id_ = 0u;
  clear_has_x_group_id();
}
inline ::google::protobuf::uint32 Response_SGXGetExtendedEpidGroupIdResponse::x_group_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse.x_group_id)
  return x_group_id_;
}
inline void Response_SGXGetExtendedEpidGroupIdResponse::set_x_group_id(::google::protobuf::uint32 value) {
  set_has_x_group_id();
  x_group_id_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.SGXGetExtendedEpidGroupIdResponse.x_group_id)
}

// -------------------------------------------------------------------

// Response_SGXSwitchExtendedEpidGroupResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SGXSwitchExtendedEpidGroupResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SGXSwitchExtendedEpidGroupResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SGXSwitchExtendedEpidGroupResponse.errorCode)
  return errorcode_;
}
inline void Response_SGXSwitchExtendedEpidGroupResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.SGXSwitchExtendedEpidGroupResponse.errorCode)
}

// -------------------------------------------------------------------

// Response_SGXRegisterResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SGXRegisterResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SGXRegisterResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SGXRegisterResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SGXRegisterResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SGXRegisterResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SGXRegisterResponse.errorCode)
  return errorcode_;
}
inline void Response_SGXRegisterResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.SGXRegisterResponse.errorCode)
}

// -------------------------------------------------------------------

// Response_SelectAttKeyIDResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_SelectAttKeyIDResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_SelectAttKeyIDResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_SelectAttKeyIDResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_SelectAttKeyIDResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_SelectAttKeyIDResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SelectAttKeyIDResponse.errorCode)
  return errorcode_;
}
inline void Response_SelectAttKeyIDResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.SelectAttKeyIDResponse.errorCode)
}

// optional bytes selected_att_key_id = 2;
inline bool Response_SelectAttKeyIDResponse::has_selected_att_key_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_SelectAttKeyIDResponse::set_has_selected_att_key_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_SelectAttKeyIDResponse::clear_has_selected_att_key_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_SelectAttKeyIDResponse::clear_selected_att_key_id() {
  selected_att_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_selected_att_key_id();
}
inline const ::std::string& Response_SelectAttKeyIDResponse::selected_att_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
  return selected_att_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_SelectAttKeyIDResponse::set_selected_att_key_id(const ::std::string& value) {
  set_has_selected_att_key_id();
  selected_att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
}
inline void Response_SelectAttKeyIDResponse::set_selected_att_key_id(const char* value) {
  set_has_selected_att_key_id();
  selected_att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
}
inline void Response_SelectAttKeyIDResponse::set_selected_att_key_id(const void* value, size_t size) {
  set_has_selected_att_key_id();
  selected_att_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
}
inline ::std::string* Response_SelectAttKeyIDResponse::mutable_selected_att_key_id() {
  set_has_selected_att_key_id();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
  return selected_att_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_SelectAttKeyIDResponse::release_selected_att_key_id() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
  clear_has_selected_att_key_id();
  return selected_att_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_SelectAttKeyIDResponse::set_allocated_selected_att_key_id(::std::string* selected_att_key_id) {
  if (selected_att_key_id != NULL) {
    set_has_selected_att_key_id();
  } else {
    clear_has_selected_att_key_id();
  }
  selected_att_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), selected_att_key_id);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.SelectAttKeyIDResponse.selected_att_key_id)
}

// -------------------------------------------------------------------

// Response_InitQuoteExResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_InitQuoteExResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_InitQuoteExResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_InitQuoteExResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_InitQuoteExResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_InitQuoteExResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteExResponse.errorCode)
  return errorcode_;
}
inline void Response_InitQuoteExResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteExResponse.errorCode)
}

// optional bytes target_info = 2;
inline bool Response_InitQuoteExResponse::has_target_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_InitQuoteExResponse::set_has_target_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_InitQuoteExResponse::clear_has_target_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_InitQuoteExResponse::clear_target_info() {
  target_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_info();
}
inline const ::std::string& Response_InitQuoteExResponse::target_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteExResponse.target_info)
  return target_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteExResponse::set_target_info(const ::std::string& value) {
  set_has_target_info();
  target_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteExResponse.target_info)
}
inline void Response_InitQuoteExResponse::set_target_info(const char* value) {
  set_has_target_info();
  target_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.InitQuoteExResponse.target_info)
}
inline void Response_InitQuoteExResponse::set_target_info(const void* value, size_t size) {
  set_has_target_info();
  target_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.InitQuoteExResponse.target_info)
}
inline ::std::string* Response_InitQuoteExResponse::mutable_target_info() {
  set_has_target_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.InitQuoteExResponse.target_info)
  return target_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_InitQuoteExResponse::release_target_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.InitQuoteExResponse.target_info)
  clear_has_target_info();
  return target_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteExResponse::set_allocated_target_info(::std::string* target_info) {
  if (target_info != NULL) {
    set_has_target_info();
  } else {
    clear_has_target_info();
  }
  target_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.InitQuoteExResponse.target_info)
}

// optional uint64 pub_key_id_size = 3;
inline bool Response_InitQuoteExResponse::has_pub_key_id_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_InitQuoteExResponse::set_has_pub_key_id_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_InitQuoteExResponse::clear_has_pub_key_id_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_InitQuoteExResponse::clear_pub_key_id_size() {
  pub_key_id_size_ = GOOGLE_ULONGLONG(0);
  clear_has_pub_key_id_size();
}
inline ::google::protobuf::uint64 Response_InitQuoteExResponse::pub_key_id_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteExResponse.pub_key_id_size)
  return pub_key_id_size_;
}
inline void Response_InitQuoteExResponse::set_pub_key_id_size(::google::protobuf::uint64 value) {
  set_has_pub_key_id_size();
  pub_key_id_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteExResponse.pub_key_id_size)
}

// optional bytes pub_key_id = 4;
inline bool Response_InitQuoteExResponse::has_pub_key_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_InitQuoteExResponse::set_has_pub_key_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_InitQuoteExResponse::clear_has_pub_key_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_InitQuoteExResponse::clear_pub_key_id() {
  pub_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pub_key_id();
}
inline const ::std::string& Response_InitQuoteExResponse::pub_key_id() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.InitQuoteExResponse.pub_key_id)
  return pub_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteExResponse::set_pub_key_id(const ::std::string& value) {
  set_has_pub_key_id();
  pub_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.InitQuoteExResponse.pub_key_id)
}
inline void Response_InitQuoteExResponse::set_pub_key_id(const char* value) {
  set_has_pub_key_id();
  pub_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.InitQuoteExResponse.pub_key_id)
}
inline void Response_InitQuoteExResponse::set_pub_key_id(const void* value, size_t size) {
  set_has_pub_key_id();
  pub_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.InitQuoteExResponse.pub_key_id)
}
inline ::std::string* Response_InitQuoteExResponse::mutable_pub_key_id() {
  set_has_pub_key_id();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.InitQuoteExResponse.pub_key_id)
  return pub_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_InitQuoteExResponse::release_pub_key_id() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.InitQuoteExResponse.pub_key_id)
  clear_has_pub_key_id();
  return pub_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_InitQuoteExResponse::set_allocated_pub_key_id(::std::string* pub_key_id) {
  if (pub_key_id != NULL) {
    set_has_pub_key_id();
  } else {
    clear_has_pub_key_id();
  }
  pub_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pub_key_id);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.InitQuoteExResponse.pub_key_id)
}

// -------------------------------------------------------------------

// Response_GetQuoteSizeExResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetQuoteSizeExResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetQuoteSizeExResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetQuoteSizeExResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetQuoteSizeExResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetQuoteSizeExResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteSizeExResponse.errorCode)
  return errorcode_;
}
inline void Response_GetQuoteSizeExResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteSizeExResponse.errorCode)
}

// optional uint32 quote_size = 2;
inline bool Response_GetQuoteSizeExResponse::has_quote_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetQuoteSizeExResponse::set_has_quote_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetQuoteSizeExResponse::clear_has_quote_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetQuoteSizeExResponse::clear_quote_size() {
  quote_size_ = 0u;
  clear_has_quote_size();
}
inline ::google::protobuf::uint32 Response_GetQuoteSizeExResponse::quote_size() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteSizeExResponse.quote_size)
  return quote_size_;
}
inline void Response_GetQuoteSizeExResponse::set_quote_size(::google::protobuf::uint32 value) {
  set_has_quote_size();
  quote_size_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteSizeExResponse.quote_size)
}

// -------------------------------------------------------------------

// Response_GetQuoteExResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetQuoteExResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetQuoteExResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetQuoteExResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetQuoteExResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetQuoteExResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteExResponse.errorCode)
  return errorcode_;
}
inline void Response_GetQuoteExResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteExResponse.errorCode)
}

// optional bytes quote = 2;
inline bool Response_GetQuoteExResponse::has_quote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetQuoteExResponse::set_has_quote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetQuoteExResponse::clear_has_quote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetQuoteExResponse::clear_quote() {
  quote_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_quote();
}
inline const ::std::string& Response_GetQuoteExResponse::quote() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteExResponse.quote)
  return quote_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteExResponse::set_quote(const ::std::string& value) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteExResponse.quote)
}
inline void Response_GetQuoteExResponse::set_quote(const char* value) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetQuoteExResponse.quote)
}
inline void Response_GetQuoteExResponse::set_quote(const void* value, size_t size) {
  set_has_quote();
  quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetQuoteExResponse.quote)
}
inline ::std::string* Response_GetQuoteExResponse::mutable_quote() {
  set_has_quote();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetQuoteExResponse.quote)
  return quote_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetQuoteExResponse::release_quote() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetQuoteExResponse.quote)
  clear_has_quote();
  return quote_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteExResponse::set_allocated_quote(::std::string* quote) {
  if (quote != NULL) {
    set_has_quote();
  } else {
    clear_has_quote();
  }
  quote_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quote);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetQuoteExResponse.quote)
}

// optional bytes qe_report_info = 3;
inline bool Response_GetQuoteExResponse::has_qe_report_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetQuoteExResponse::set_has_qe_report_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetQuoteExResponse::clear_has_qe_report_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetQuoteExResponse::clear_qe_report_info() {
  qe_report_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qe_report_info();
}
inline const ::std::string& Response_GetQuoteExResponse::qe_report_info() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetQuoteExResponse.qe_report_info)
  return qe_report_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteExResponse::set_qe_report_info(const ::std::string& value) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetQuoteExResponse.qe_report_info)
}
inline void Response_GetQuoteExResponse::set_qe_report_info(const char* value) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetQuoteExResponse.qe_report_info)
}
inline void Response_GetQuoteExResponse::set_qe_report_info(const void* value, size_t size) {
  set_has_qe_report_info();
  qe_report_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetQuoteExResponse.qe_report_info)
}
inline ::std::string* Response_GetQuoteExResponse::mutable_qe_report_info() {
  set_has_qe_report_info();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetQuoteExResponse.qe_report_info)
  return qe_report_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetQuoteExResponse::release_qe_report_info() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetQuoteExResponse.qe_report_info)
  clear_has_qe_report_info();
  return qe_report_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetQuoteExResponse::set_allocated_qe_report_info(::std::string* qe_report_info) {
  if (qe_report_info != NULL) {
    set_has_qe_report_info();
  } else {
    clear_has_qe_report_info();
  }
  qe_report_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qe_report_info);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetQuoteExResponse.qe_report_info)
}

// -------------------------------------------------------------------

// Response_UnsupportedRequestResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_UnsupportedRequestResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_UnsupportedRequestResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_UnsupportedRequestResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_UnsupportedRequestResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_UnsupportedRequestResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.UnsupportedRequestResponse.errorCode)
  return errorcode_;
}
inline void Response_UnsupportedRequestResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.UnsupportedRequestResponse.errorCode)
}

// -------------------------------------------------------------------

// Response_GetSupportedAttKeyIDNumResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetSupportedAttKeyIDNumResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetSupportedAttKeyIDNumResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetSupportedAttKeyIDNumResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetSupportedAttKeyIDNumResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetSupportedAttKeyIDNumResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetSupportedAttKeyIDNumResponse.errorCode)
  return errorcode_;
}
inline void Response_GetSupportedAttKeyIDNumResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetSupportedAttKeyIDNumResponse.errorCode)
}

// optional uint32 att_key_id_num = 2;
inline bool Response_GetSupportedAttKeyIDNumResponse::has_att_key_id_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetSupportedAttKeyIDNumResponse::set_has_att_key_id_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetSupportedAttKeyIDNumResponse::clear_has_att_key_id_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetSupportedAttKeyIDNumResponse::clear_att_key_id_num() {
  att_key_id_num_ = 0u;
  clear_has_att_key_id_num();
}
inline ::google::protobuf::uint32 Response_GetSupportedAttKeyIDNumResponse::att_key_id_num() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetSupportedAttKeyIDNumResponse.att_key_id_num)
  return att_key_id_num_;
}
inline void Response_GetSupportedAttKeyIDNumResponse::set_att_key_id_num(::google::protobuf::uint32 value) {
  set_has_att_key_id_num();
  att_key_id_num_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetSupportedAttKeyIDNumResponse.att_key_id_num)
}

// -------------------------------------------------------------------

// Response_GetSupportedAttKeyIDsResponse

// required uint32 errorCode = 1 [default = 1];
inline bool Response_GetSupportedAttKeyIDsResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetSupportedAttKeyIDsResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetSupportedAttKeyIDsResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetSupportedAttKeyIDsResponse::clear_errorcode() {
  errorcode_ = 1u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 Response_GetSupportedAttKeyIDsResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetSupportedAttKeyIDsResponse.errorCode)
  return errorcode_;
}
inline void Response_GetSupportedAttKeyIDsResponse::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetSupportedAttKeyIDsResponse.errorCode)
}

// optional bytes att_key_ids = 2;
inline bool Response_GetSupportedAttKeyIDsResponse::has_att_key_ids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetSupportedAttKeyIDsResponse::set_has_att_key_ids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetSupportedAttKeyIDsResponse::clear_has_att_key_ids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetSupportedAttKeyIDsResponse::clear_att_key_ids() {
  att_key_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_att_key_ids();
}
inline const ::std::string& Response_GetSupportedAttKeyIDsResponse::att_key_ids() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
  return att_key_ids_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetSupportedAttKeyIDsResponse::set_att_key_ids(const ::std::string& value) {
  set_has_att_key_ids();
  att_key_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
}
inline void Response_GetSupportedAttKeyIDsResponse::set_att_key_ids(const char* value) {
  set_has_att_key_ids();
  att_key_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
}
inline void Response_GetSupportedAttKeyIDsResponse::set_att_key_ids(const void* value, size_t size) {
  set_has_att_key_ids();
  att_key_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
}
inline ::std::string* Response_GetSupportedAttKeyIDsResponse::mutable_att_key_ids() {
  set_has_att_key_ids();
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
  return att_key_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetSupportedAttKeyIDsResponse::release_att_key_ids() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
  clear_has_att_key_ids();
  return att_key_ids_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetSupportedAttKeyIDsResponse::set_allocated_att_key_ids(::std::string* att_key_ids) {
  if (att_key_ids != NULL) {
    set_has_att_key_ids();
  } else {
    clear_has_att_key_ids();
  }
  att_key_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), att_key_ids);
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.GetSupportedAttKeyIDsResponse.att_key_ids)
}

// -------------------------------------------------------------------

// Response

// optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;
inline bool Response::has_initquoteres() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_initquoteres() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_initquoteres() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_initquoteres() {
  if (initquoteres_ != NULL) initquoteres_->::aesm::message::Response_InitQuoteResponse::Clear();
  clear_has_initquoteres();
}
inline const ::aesm::message::Response_InitQuoteResponse& Response::initquoteres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.initQuoteRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initquoteres_ != NULL ? *initquoteres_ : *default_instance().initquoteres_;
#else
  return initquoteres_ != NULL ? *initquoteres_ : *default_instance_->initquoteres_;
#endif
}
inline ::aesm::message::Response_InitQuoteResponse* Response::mutable_initquoteres() {
  set_has_initquoteres();
  if (initquoteres_ == NULL) {
    initquoteres_ = new ::aesm::message::Response_InitQuoteResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.initQuoteRes)
  return initquoteres_;
}
inline ::aesm::message::Response_InitQuoteResponse* Response::release_initquoteres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.initQuoteRes)
  clear_has_initquoteres();
  ::aesm::message::Response_InitQuoteResponse* temp = initquoteres_;
  initquoteres_ = NULL;
  return temp;
}
inline void Response::set_allocated_initquoteres(::aesm::message::Response_InitQuoteResponse* initquoteres) {
  delete initquoteres_;
  initquoteres_ = initquoteres;
  if (initquoteres) {
    set_has_initquoteres();
  } else {
    clear_has_initquoteres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.initQuoteRes)
}

// optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;
inline bool Response::has_getquoteres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_getquoteres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_getquoteres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_getquoteres() {
  if (getquoteres_ != NULL) getquoteres_->::aesm::message::Response_GetQuoteResponse::Clear();
  clear_has_getquoteres();
}
inline const ::aesm::message::Response_GetQuoteResponse& Response::getquoteres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getQuoteRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquoteres_ != NULL ? *getquoteres_ : *default_instance().getquoteres_;
#else
  return getquoteres_ != NULL ? *getquoteres_ : *default_instance_->getquoteres_;
#endif
}
inline ::aesm::message::Response_GetQuoteResponse* Response::mutable_getquoteres() {
  set_has_getquoteres();
  if (getquoteres_ == NULL) {
    getquoteres_ = new ::aesm::message::Response_GetQuoteResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getQuoteRes)
  return getquoteres_;
}
inline ::aesm::message::Response_GetQuoteResponse* Response::release_getquoteres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getQuoteRes)
  clear_has_getquoteres();
  ::aesm::message::Response_GetQuoteResponse* temp = getquoteres_;
  getquoteres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getquoteres(::aesm::message::Response_GetQuoteResponse* getquoteres) {
  delete getquoteres_;
  getquoteres_ = getquoteres;
  if (getquoteres) {
    set_has_getquoteres();
  } else {
    clear_has_getquoteres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getQuoteRes)
}

// optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;
inline bool Response::has_getlictokenres() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_getlictokenres() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_getlictokenres() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_getlictokenres() {
  if (getlictokenres_ != NULL) getlictokenres_->::aesm::message::Response_GetLaunchTokenResponse::Clear();
  clear_has_getlictokenres();
}
inline const ::aesm::message::Response_GetLaunchTokenResponse& Response::getlictokenres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getLicTokenRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getlictokenres_ != NULL ? *getlictokenres_ : *default_instance().getlictokenres_;
#else
  return getlictokenres_ != NULL ? *getlictokenres_ : *default_instance_->getlictokenres_;
#endif
}
inline ::aesm::message::Response_GetLaunchTokenResponse* Response::mutable_getlictokenres() {
  set_has_getlictokenres();
  if (getlictokenres_ == NULL) {
    getlictokenres_ = new ::aesm::message::Response_GetLaunchTokenResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getLicTokenRes)
  return getlictokenres_;
}
inline ::aesm::message::Response_GetLaunchTokenResponse* Response::release_getlictokenres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getLicTokenRes)
  clear_has_getlictokenres();
  ::aesm::message::Response_GetLaunchTokenResponse* temp = getlictokenres_;
  getlictokenres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getlictokenres(::aesm::message::Response_GetLaunchTokenResponse* getlictokenres) {
  delete getlictokenres_;
  getlictokenres_ = getlictokenres;
  if (getlictokenres) {
    set_has_getlictokenres();
  } else {
    clear_has_getlictokenres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getLicTokenRes)
}

// optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;
inline bool Response::has_reporterrres() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_reporterrres() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_reporterrres() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_reporterrres() {
  if (reporterrres_ != NULL) reporterrres_->::aesm::message::Response_ReportAttestationErrorResponse::Clear();
  clear_has_reporterrres();
}
inline const ::aesm::message::Response_ReportAttestationErrorResponse& Response::reporterrres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.reportErrRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reporterrres_ != NULL ? *reporterrres_ : *default_instance().reporterrres_;
#else
  return reporterrres_ != NULL ? *reporterrres_ : *default_instance_->reporterrres_;
#endif
}
inline ::aesm::message::Response_ReportAttestationErrorResponse* Response::mutable_reporterrres() {
  set_has_reporterrres();
  if (reporterrres_ == NULL) {
    reporterrres_ = new ::aesm::message::Response_ReportAttestationErrorResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.reportErrRes)
  return reporterrres_;
}
inline ::aesm::message::Response_ReportAttestationErrorResponse* Response::release_reporterrres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.reportErrRes)
  clear_has_reporterrres();
  ::aesm::message::Response_ReportAttestationErrorResponse* temp = reporterrres_;
  reporterrres_ = NULL;
  return temp;
}
inline void Response::set_allocated_reporterrres(::aesm::message::Response_ReportAttestationErrorResponse* reporterrres) {
  delete reporterrres_;
  reporterrres_ = reporterrres;
  if (reporterrres) {
    set_has_reporterrres();
  } else {
    clear_has_reporterrres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.reportErrRes)
}

// optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;
inline bool Response::has_getwhitelistsizeres() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_getwhitelistsizeres() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_getwhitelistsizeres() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_getwhitelistsizeres() {
  if (getwhitelistsizeres_ != NULL) getwhitelistsizeres_->::aesm::message::Response_GetWhiteListSizeResponse::Clear();
  clear_has_getwhitelistsizeres();
}
inline const ::aesm::message::Response_GetWhiteListSizeResponse& Response::getwhitelistsizeres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getWhiteListSizeRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getwhitelistsizeres_ != NULL ? *getwhitelistsizeres_ : *default_instance().getwhitelistsizeres_;
#else
  return getwhitelistsizeres_ != NULL ? *getwhitelistsizeres_ : *default_instance_->getwhitelistsizeres_;
#endif
}
inline ::aesm::message::Response_GetWhiteListSizeResponse* Response::mutable_getwhitelistsizeres() {
  set_has_getwhitelistsizeres();
  if (getwhitelistsizeres_ == NULL) {
    getwhitelistsizeres_ = new ::aesm::message::Response_GetWhiteListSizeResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getWhiteListSizeRes)
  return getwhitelistsizeres_;
}
inline ::aesm::message::Response_GetWhiteListSizeResponse* Response::release_getwhitelistsizeres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getWhiteListSizeRes)
  clear_has_getwhitelistsizeres();
  ::aesm::message::Response_GetWhiteListSizeResponse* temp = getwhitelistsizeres_;
  getwhitelistsizeres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getwhitelistsizeres(::aesm::message::Response_GetWhiteListSizeResponse* getwhitelistsizeres) {
  delete getwhitelistsizeres_;
  getwhitelistsizeres_ = getwhitelistsizeres;
  if (getwhitelistsizeres) {
    set_has_getwhitelistsizeres();
  } else {
    clear_has_getwhitelistsizeres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getWhiteListSizeRes)
}

// optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;
inline bool Response::has_getwhitelistres() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_getwhitelistres() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_getwhitelistres() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_getwhitelistres() {
  if (getwhitelistres_ != NULL) getwhitelistres_->::aesm::message::Response_GetWhiteListResponse::Clear();
  clear_has_getwhitelistres();
}
inline const ::aesm::message::Response_GetWhiteListResponse& Response::getwhitelistres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getWhiteListRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getwhitelistres_ != NULL ? *getwhitelistres_ : *default_instance().getwhitelistres_;
#else
  return getwhitelistres_ != NULL ? *getwhitelistres_ : *default_instance_->getwhitelistres_;
#endif
}
inline ::aesm::message::Response_GetWhiteListResponse* Response::mutable_getwhitelistres() {
  set_has_getwhitelistres();
  if (getwhitelistres_ == NULL) {
    getwhitelistres_ = new ::aesm::message::Response_GetWhiteListResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getWhiteListRes)
  return getwhitelistres_;
}
inline ::aesm::message::Response_GetWhiteListResponse* Response::release_getwhitelistres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getWhiteListRes)
  clear_has_getwhitelistres();
  ::aesm::message::Response_GetWhiteListResponse* temp = getwhitelistres_;
  getwhitelistres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getwhitelistres(::aesm::message::Response_GetWhiteListResponse* getwhitelistres) {
  delete getwhitelistres_;
  getwhitelistres_ = getwhitelistres;
  if (getwhitelistres) {
    set_has_getwhitelistres();
  } else {
    clear_has_getwhitelistres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getWhiteListRes)
}

// optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;
inline bool Response::has_sgxgetextendedepidgroupidres() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_sgxgetextendedepidgroupidres() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_sgxgetextendedepidgroupidres() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_sgxgetextendedepidgroupidres() {
  if (sgxgetextendedepidgroupidres_ != NULL) sgxgetextendedepidgroupidres_->::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse::Clear();
  clear_has_sgxgetextendedepidgroupidres();
}
inline const ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse& Response::sgxgetextendedepidgroupidres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.sgxGetExtendedEpidGroupIdRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxgetextendedepidgroupidres_ != NULL ? *sgxgetextendedepidgroupidres_ : *default_instance().sgxgetextendedepidgroupidres_;
#else
  return sgxgetextendedepidgroupidres_ != NULL ? *sgxgetextendedepidgroupidres_ : *default_instance_->sgxgetextendedepidgroupidres_;
#endif
}
inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* Response::mutable_sgxgetextendedepidgroupidres() {
  set_has_sgxgetextendedepidgroupidres();
  if (sgxgetextendedepidgroupidres_ == NULL) {
    sgxgetextendedepidgroupidres_ = new ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.sgxGetExtendedEpidGroupIdRes)
  return sgxgetextendedepidgroupidres_;
}
inline ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* Response::release_sgxgetextendedepidgroupidres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.sgxGetExtendedEpidGroupIdRes)
  clear_has_sgxgetextendedepidgroupidres();
  ::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* temp = sgxgetextendedepidgroupidres_;
  sgxgetextendedepidgroupidres_ = NULL;
  return temp;
}
inline void Response::set_allocated_sgxgetextendedepidgroupidres(::aesm::message::Response_SGXGetExtendedEpidGroupIdResponse* sgxgetextendedepidgroupidres) {
  delete sgxgetextendedepidgroupidres_;
  sgxgetextendedepidgroupidres_ = sgxgetextendedepidgroupidres;
  if (sgxgetextendedepidgroupidres) {
    set_has_sgxgetextendedepidgroupidres();
  } else {
    clear_has_sgxgetextendedepidgroupidres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.sgxGetExtendedEpidGroupIdRes)
}

// optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;
inline bool Response::has_sgxswitchextendedepidgroupres() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_sgxswitchextendedepidgroupres() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_sgxswitchextendedepidgroupres() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_sgxswitchextendedepidgroupres() {
  if (sgxswitchextendedepidgroupres_ != NULL) sgxswitchextendedepidgroupres_->::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse::Clear();
  clear_has_sgxswitchextendedepidgroupres();
}
inline const ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse& Response::sgxswitchextendedepidgroupres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.sgxSwitchExtendedEpidGroupRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxswitchextendedepidgroupres_ != NULL ? *sgxswitchextendedepidgroupres_ : *default_instance().sgxswitchextendedepidgroupres_;
#else
  return sgxswitchextendedepidgroupres_ != NULL ? *sgxswitchextendedepidgroupres_ : *default_instance_->sgxswitchextendedepidgroupres_;
#endif
}
inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* Response::mutable_sgxswitchextendedepidgroupres() {
  set_has_sgxswitchextendedepidgroupres();
  if (sgxswitchextendedepidgroupres_ == NULL) {
    sgxswitchextendedepidgroupres_ = new ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.sgxSwitchExtendedEpidGroupRes)
  return sgxswitchextendedepidgroupres_;
}
inline ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* Response::release_sgxswitchextendedepidgroupres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.sgxSwitchExtendedEpidGroupRes)
  clear_has_sgxswitchextendedepidgroupres();
  ::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* temp = sgxswitchextendedepidgroupres_;
  sgxswitchextendedepidgroupres_ = NULL;
  return temp;
}
inline void Response::set_allocated_sgxswitchextendedepidgroupres(::aesm::message::Response_SGXSwitchExtendedEpidGroupResponse* sgxswitchextendedepidgroupres) {
  delete sgxswitchextendedepidgroupres_;
  sgxswitchextendedepidgroupres_ = sgxswitchextendedepidgroupres;
  if (sgxswitchextendedepidgroupres) {
    set_has_sgxswitchextendedepidgroupres();
  } else {
    clear_has_sgxswitchextendedepidgroupres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.sgxSwitchExtendedEpidGroupRes)
}

// optional .aesm.message.Response.SGXRegisterResponse sgxRegisterRes = 14;
inline bool Response::has_sgxregisterres() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_sgxregisterres() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_sgxregisterres() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_sgxregisterres() {
  if (sgxregisterres_ != NULL) sgxregisterres_->::aesm::message::Response_SGXRegisterResponse::Clear();
  clear_has_sgxregisterres();
}
inline const ::aesm::message::Response_SGXRegisterResponse& Response::sgxregisterres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.sgxRegisterRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sgxregisterres_ != NULL ? *sgxregisterres_ : *default_instance().sgxregisterres_;
#else
  return sgxregisterres_ != NULL ? *sgxregisterres_ : *default_instance_->sgxregisterres_;
#endif
}
inline ::aesm::message::Response_SGXRegisterResponse* Response::mutable_sgxregisterres() {
  set_has_sgxregisterres();
  if (sgxregisterres_ == NULL) {
    sgxregisterres_ = new ::aesm::message::Response_SGXRegisterResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.sgxRegisterRes)
  return sgxregisterres_;
}
inline ::aesm::message::Response_SGXRegisterResponse* Response::release_sgxregisterres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.sgxRegisterRes)
  clear_has_sgxregisterres();
  ::aesm::message::Response_SGXRegisterResponse* temp = sgxregisterres_;
  sgxregisterres_ = NULL;
  return temp;
}
inline void Response::set_allocated_sgxregisterres(::aesm::message::Response_SGXRegisterResponse* sgxregisterres) {
  delete sgxregisterres_;
  sgxregisterres_ = sgxregisterres;
  if (sgxregisterres) {
    set_has_sgxregisterres();
  } else {
    clear_has_sgxregisterres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.sgxRegisterRes)
}

// optional .aesm.message.Response.InitQuoteExResponse initQuoteExRes = 15;
inline bool Response::has_initquoteexres() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_initquoteexres() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_initquoteexres() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_initquoteexres() {
  if (initquoteexres_ != NULL) initquoteexres_->::aesm::message::Response_InitQuoteExResponse::Clear();
  clear_has_initquoteexres();
}
inline const ::aesm::message::Response_InitQuoteExResponse& Response::initquoteexres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.initQuoteExRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initquoteexres_ != NULL ? *initquoteexres_ : *default_instance().initquoteexres_;
#else
  return initquoteexres_ != NULL ? *initquoteexres_ : *default_instance_->initquoteexres_;
#endif
}
inline ::aesm::message::Response_InitQuoteExResponse* Response::mutable_initquoteexres() {
  set_has_initquoteexres();
  if (initquoteexres_ == NULL) {
    initquoteexres_ = new ::aesm::message::Response_InitQuoteExResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.initQuoteExRes)
  return initquoteexres_;
}
inline ::aesm::message::Response_InitQuoteExResponse* Response::release_initquoteexres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.initQuoteExRes)
  clear_has_initquoteexres();
  ::aesm::message::Response_InitQuoteExResponse* temp = initquoteexres_;
  initquoteexres_ = NULL;
  return temp;
}
inline void Response::set_allocated_initquoteexres(::aesm::message::Response_InitQuoteExResponse* initquoteexres) {
  delete initquoteexres_;
  initquoteexres_ = initquoteexres;
  if (initquoteexres) {
    set_has_initquoteexres();
  } else {
    clear_has_initquoteexres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.initQuoteExRes)
}

// optional .aesm.message.Response.GetQuoteSizeExResponse getQuoteSizeExRes = 16;
inline bool Response::has_getquotesizeexres() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_getquotesizeexres() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_getquotesizeexres() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_getquotesizeexres() {
  if (getquotesizeexres_ != NULL) getquotesizeexres_->::aesm::message::Response_GetQuoteSizeExResponse::Clear();
  clear_has_getquotesizeexres();
}
inline const ::aesm::message::Response_GetQuoteSizeExResponse& Response::getquotesizeexres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getQuoteSizeExRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquotesizeexres_ != NULL ? *getquotesizeexres_ : *default_instance().getquotesizeexres_;
#else
  return getquotesizeexres_ != NULL ? *getquotesizeexres_ : *default_instance_->getquotesizeexres_;
#endif
}
inline ::aesm::message::Response_GetQuoteSizeExResponse* Response::mutable_getquotesizeexres() {
  set_has_getquotesizeexres();
  if (getquotesizeexres_ == NULL) {
    getquotesizeexres_ = new ::aesm::message::Response_GetQuoteSizeExResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getQuoteSizeExRes)
  return getquotesizeexres_;
}
inline ::aesm::message::Response_GetQuoteSizeExResponse* Response::release_getquotesizeexres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getQuoteSizeExRes)
  clear_has_getquotesizeexres();
  ::aesm::message::Response_GetQuoteSizeExResponse* temp = getquotesizeexres_;
  getquotesizeexres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getquotesizeexres(::aesm::message::Response_GetQuoteSizeExResponse* getquotesizeexres) {
  delete getquotesizeexres_;
  getquotesizeexres_ = getquotesizeexres;
  if (getquotesizeexres) {
    set_has_getquotesizeexres();
  } else {
    clear_has_getquotesizeexres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getQuoteSizeExRes)
}

// optional .aesm.message.Response.GetQuoteExResponse getQuoteExRes = 17;
inline bool Response::has_getquoteexres() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_getquoteexres() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_getquoteexres() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_getquoteexres() {
  if (getquoteexres_ != NULL) getquoteexres_->::aesm::message::Response_GetQuoteExResponse::Clear();
  clear_has_getquoteexres();
}
inline const ::aesm::message::Response_GetQuoteExResponse& Response::getquoteexres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getQuoteExRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getquoteexres_ != NULL ? *getquoteexres_ : *default_instance().getquoteexres_;
#else
  return getquoteexres_ != NULL ? *getquoteexres_ : *default_instance_->getquoteexres_;
#endif
}
inline ::aesm::message::Response_GetQuoteExResponse* Response::mutable_getquoteexres() {
  set_has_getquoteexres();
  if (getquoteexres_ == NULL) {
    getquoteexres_ = new ::aesm::message::Response_GetQuoteExResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getQuoteExRes)
  return getquoteexres_;
}
inline ::aesm::message::Response_GetQuoteExResponse* Response::release_getquoteexres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getQuoteExRes)
  clear_has_getquoteexres();
  ::aesm::message::Response_GetQuoteExResponse* temp = getquoteexres_;
  getquoteexres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getquoteexres(::aesm::message::Response_GetQuoteExResponse* getquoteexres) {
  delete getquoteexres_;
  getquoteexres_ = getquoteexres;
  if (getquoteexres) {
    set_has_getquoteexres();
  } else {
    clear_has_getquoteexres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getQuoteExRes)
}

// optional .aesm.message.Response.CheckUpdateStatusResponse checkUpdateStatusRes = 18;
inline bool Response::has_checkupdatestatusres() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_checkupdatestatusres() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_checkupdatestatusres() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_checkupdatestatusres() {
  if (checkupdatestatusres_ != NULL) checkupdatestatusres_->::aesm::message::Response_CheckUpdateStatusResponse::Clear();
  clear_has_checkupdatestatusres();
}
inline const ::aesm::message::Response_CheckUpdateStatusResponse& Response::checkupdatestatusres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.checkUpdateStatusRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checkupdatestatusres_ != NULL ? *checkupdatestatusres_ : *default_instance().checkupdatestatusres_;
#else
  return checkupdatestatusres_ != NULL ? *checkupdatestatusres_ : *default_instance_->checkupdatestatusres_;
#endif
}
inline ::aesm::message::Response_CheckUpdateStatusResponse* Response::mutable_checkupdatestatusres() {
  set_has_checkupdatestatusres();
  if (checkupdatestatusres_ == NULL) {
    checkupdatestatusres_ = new ::aesm::message::Response_CheckUpdateStatusResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.checkUpdateStatusRes)
  return checkupdatestatusres_;
}
inline ::aesm::message::Response_CheckUpdateStatusResponse* Response::release_checkupdatestatusres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.checkUpdateStatusRes)
  clear_has_checkupdatestatusres();
  ::aesm::message::Response_CheckUpdateStatusResponse* temp = checkupdatestatusres_;
  checkupdatestatusres_ = NULL;
  return temp;
}
inline void Response::set_allocated_checkupdatestatusres(::aesm::message::Response_CheckUpdateStatusResponse* checkupdatestatusres) {
  delete checkupdatestatusres_;
  checkupdatestatusres_ = checkupdatestatusres;
  if (checkupdatestatusres) {
    set_has_checkupdatestatusres();
  } else {
    clear_has_checkupdatestatusres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.checkUpdateStatusRes)
}

// optional .aesm.message.Response.SelectAttKeyIDResponse selectAttKeyIDRes = 19;
inline bool Response::has_selectattkeyidres() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Response::set_has_selectattkeyidres() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Response::clear_has_selectattkeyidres() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Response::clear_selectattkeyidres() {
  if (selectattkeyidres_ != NULL) selectattkeyidres_->::aesm::message::Response_SelectAttKeyIDResponse::Clear();
  clear_has_selectattkeyidres();
}
inline const ::aesm::message::Response_SelectAttKeyIDResponse& Response::selectattkeyidres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.selectAttKeyIDRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selectattkeyidres_ != NULL ? *selectattkeyidres_ : *default_instance().selectattkeyidres_;
#else
  return selectattkeyidres_ != NULL ? *selectattkeyidres_ : *default_instance_->selectattkeyidres_;
#endif
}
inline ::aesm::message::Response_SelectAttKeyIDResponse* Response::mutable_selectattkeyidres() {
  set_has_selectattkeyidres();
  if (selectattkeyidres_ == NULL) {
    selectattkeyidres_ = new ::aesm::message::Response_SelectAttKeyIDResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.selectAttKeyIDRes)
  return selectattkeyidres_;
}
inline ::aesm::message::Response_SelectAttKeyIDResponse* Response::release_selectattkeyidres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.selectAttKeyIDRes)
  clear_has_selectattkeyidres();
  ::aesm::message::Response_SelectAttKeyIDResponse* temp = selectattkeyidres_;
  selectattkeyidres_ = NULL;
  return temp;
}
inline void Response::set_allocated_selectattkeyidres(::aesm::message::Response_SelectAttKeyIDResponse* selectattkeyidres) {
  delete selectattkeyidres_;
  selectattkeyidres_ = selectattkeyidres;
  if (selectattkeyidres) {
    set_has_selectattkeyidres();
  } else {
    clear_has_selectattkeyidres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.selectAttKeyIDRes)
}

// optional .aesm.message.Response.UnsupportedRequestResponse unsupportedRequestResponse = 20;
inline bool Response::has_unsupportedrequestresponse() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Response::set_has_unsupportedrequestresponse() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Response::clear_has_unsupportedrequestresponse() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Response::clear_unsupportedrequestresponse() {
  if (unsupportedrequestresponse_ != NULL) unsupportedrequestresponse_->::aesm::message::Response_UnsupportedRequestResponse::Clear();
  clear_has_unsupportedrequestresponse();
}
inline const ::aesm::message::Response_UnsupportedRequestResponse& Response::unsupportedrequestresponse() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.unsupportedRequestResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unsupportedrequestresponse_ != NULL ? *unsupportedrequestresponse_ : *default_instance().unsupportedrequestresponse_;
#else
  return unsupportedrequestresponse_ != NULL ? *unsupportedrequestresponse_ : *default_instance_->unsupportedrequestresponse_;
#endif
}
inline ::aesm::message::Response_UnsupportedRequestResponse* Response::mutable_unsupportedrequestresponse() {
  set_has_unsupportedrequestresponse();
  if (unsupportedrequestresponse_ == NULL) {
    unsupportedrequestresponse_ = new ::aesm::message::Response_UnsupportedRequestResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.unsupportedRequestResponse)
  return unsupportedrequestresponse_;
}
inline ::aesm::message::Response_UnsupportedRequestResponse* Response::release_unsupportedrequestresponse() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.unsupportedRequestResponse)
  clear_has_unsupportedrequestresponse();
  ::aesm::message::Response_UnsupportedRequestResponse* temp = unsupportedrequestresponse_;
  unsupportedrequestresponse_ = NULL;
  return temp;
}
inline void Response::set_allocated_unsupportedrequestresponse(::aesm::message::Response_UnsupportedRequestResponse* unsupportedrequestresponse) {
  delete unsupportedrequestresponse_;
  unsupportedrequestresponse_ = unsupportedrequestresponse;
  if (unsupportedrequestresponse) {
    set_has_unsupportedrequestresponse();
  } else {
    clear_has_unsupportedrequestresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.unsupportedRequestResponse)
}

// optional .aesm.message.Response.GetSupportedAttKeyIDNumResponse getSupportedAttKeyIDNumRes = 21;
inline bool Response::has_getsupportedattkeyidnumres() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Response::set_has_getsupportedattkeyidnumres() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Response::clear_has_getsupportedattkeyidnumres() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Response::clear_getsupportedattkeyidnumres() {
  if (getsupportedattkeyidnumres_ != NULL) getsupportedattkeyidnumres_->::aesm::message::Response_GetSupportedAttKeyIDNumResponse::Clear();
  clear_has_getsupportedattkeyidnumres();
}
inline const ::aesm::message::Response_GetSupportedAttKeyIDNumResponse& Response::getsupportedattkeyidnumres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getSupportedAttKeyIDNumRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getsupportedattkeyidnumres_ != NULL ? *getsupportedattkeyidnumres_ : *default_instance().getsupportedattkeyidnumres_;
#else
  return getsupportedattkeyidnumres_ != NULL ? *getsupportedattkeyidnumres_ : *default_instance_->getsupportedattkeyidnumres_;
#endif
}
inline ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* Response::mutable_getsupportedattkeyidnumres() {
  set_has_getsupportedattkeyidnumres();
  if (getsupportedattkeyidnumres_ == NULL) {
    getsupportedattkeyidnumres_ = new ::aesm::message::Response_GetSupportedAttKeyIDNumResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getSupportedAttKeyIDNumRes)
  return getsupportedattkeyidnumres_;
}
inline ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* Response::release_getsupportedattkeyidnumres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getSupportedAttKeyIDNumRes)
  clear_has_getsupportedattkeyidnumres();
  ::aesm::message::Response_GetSupportedAttKeyIDNumResponse* temp = getsupportedattkeyidnumres_;
  getsupportedattkeyidnumres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getsupportedattkeyidnumres(::aesm::message::Response_GetSupportedAttKeyIDNumResponse* getsupportedattkeyidnumres) {
  delete getsupportedattkeyidnumres_;
  getsupportedattkeyidnumres_ = getsupportedattkeyidnumres;
  if (getsupportedattkeyidnumres) {
    set_has_getsupportedattkeyidnumres();
  } else {
    clear_has_getsupportedattkeyidnumres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getSupportedAttKeyIDNumRes)
}

// optional .aesm.message.Response.GetSupportedAttKeyIDsResponse getSupportedAttKeyIDsRes = 22;
inline bool Response::has_getsupportedattkeyidsres() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Response::set_has_getsupportedattkeyidsres() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Response::clear_has_getsupportedattkeyidsres() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Response::clear_getsupportedattkeyidsres() {
  if (getsupportedattkeyidsres_ != NULL) getsupportedattkeyidsres_->::aesm::message::Response_GetSupportedAttKeyIDsResponse::Clear();
  clear_has_getsupportedattkeyidsres();
}
inline const ::aesm::message::Response_GetSupportedAttKeyIDsResponse& Response::getsupportedattkeyidsres() const {
  // @@protoc_insertion_point(field_get:aesm.message.Response.getSupportedAttKeyIDsRes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getsupportedattkeyidsres_ != NULL ? *getsupportedattkeyidsres_ : *default_instance().getsupportedattkeyidsres_;
#else
  return getsupportedattkeyidsres_ != NULL ? *getsupportedattkeyidsres_ : *default_instance_->getsupportedattkeyidsres_;
#endif
}
inline ::aesm::message::Response_GetSupportedAttKeyIDsResponse* Response::mutable_getsupportedattkeyidsres() {
  set_has_getsupportedattkeyidsres();
  if (getsupportedattkeyidsres_ == NULL) {
    getsupportedattkeyidsres_ = new ::aesm::message::Response_GetSupportedAttKeyIDsResponse;
  }
  // @@protoc_insertion_point(field_mutable:aesm.message.Response.getSupportedAttKeyIDsRes)
  return getsupportedattkeyidsres_;
}
inline ::aesm::message::Response_GetSupportedAttKeyIDsResponse* Response::release_getsupportedattkeyidsres() {
  // @@protoc_insertion_point(field_release:aesm.message.Response.getSupportedAttKeyIDsRes)
  clear_has_getsupportedattkeyidsres();
  ::aesm::message::Response_GetSupportedAttKeyIDsResponse* temp = getsupportedattkeyidsres_;
  getsupportedattkeyidsres_ = NULL;
  return temp;
}
inline void Response::set_allocated_getsupportedattkeyidsres(::aesm::message::Response_GetSupportedAttKeyIDsResponse* getsupportedattkeyidsres) {
  delete getsupportedattkeyidsres_;
  getsupportedattkeyidsres_ = getsupportedattkeyidsres;
  if (getsupportedattkeyidsres) {
    set_has_getsupportedattkeyidsres();
  } else {
    clear_has_getsupportedattkeyidsres();
  }
  // @@protoc_insertion_point(field_set_allocated:aesm.message.Response.getSupportedAttKeyIDsRes)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace aesm

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
